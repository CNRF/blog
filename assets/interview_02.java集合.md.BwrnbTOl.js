import{_ as d,c as e,o as a,a3 as r}from"./chunks/framework.DY6izP8J.js";const o="/blog/assets/1751419904115.DCNlmpBG.png",b=JSON.parse('{"title":"02.java集合","description":"","frontmatter":{"title":"02.java集合","tags":[""],"categories":[""]},"headers":[],"relativePath":"interview/02.java集合.md","filePath":"interview/02.java集合.md","lastUpdated":1751421719000}'),h={name:"interview/02.java集合.md"};function s(c,t,i,l,n,p){return a(),e("div",null,t[0]||(t[0]=[r('<h3 id="list-set-queue-map-四者的区别" tabindex="-1">List, Set, Queue, Map 四者的区别 <a class="header-anchor" href="#list-set-queue-map-四者的区别" aria-label="Permalink to &quot;List, Set, Queue, Map 四者的区别&quot;">​</a></h3><table><thead><tr><th>特性/接口</th><th><code>List</code></th><th><code>Set</code></th><th><code>Queue</code></th><th><code>Map</code></th></tr></thead><tbody><tr><td>是否允许重复元素</td><td>✅ 允许</td><td>❌ 不允许</td><td>✅ 允许</td><td>✅ 值可重复，键不可重复</td></tr><tr><td>是否有序</td><td>✅ 有序（插入顺序）</td><td>❌ 通常无序（可排序）</td><td>✅ 通常按队列顺序（FIFO）</td><td>❌ 无序（可按 key 排序）</td></tr><tr><td>元素访问方式</td><td>下标访问</td><td>无索引，迭代器</td><td>队头/队尾操作</td><td>通过 <code>key</code> 访问 <code>value</code></td></tr><tr><td>数据结构特征</td><td>动态数组或链表</td><td>哈希或树结构</td><td>环形数组/链表/优先队列等</td><td>哈希表、红黑树等结构</td></tr><tr><td>典型场景</td><td>有序集合、频繁查找</td><td>去重集合、快速包含判断</td><td>消息队列、任务排队</td><td>键值映射、缓存</td></tr><tr><td>主要实现类</td><td><code>ArrayList</code>, <code>LinkedList</code></td><td><code>HashSet</code>, <code>TreeSet</code></td><td><code>LinkedList</code>, <code>PriorityQueue</code></td><td><code>HashMap</code>, <code>TreeMap</code></td></tr></tbody></table><h3 id="arraylist-和-linkedlist-的区别" tabindex="-1">ArrayList 和 LinkedList 的区别 <a class="header-anchor" href="#arraylist-和-linkedlist-的区别" aria-label="Permalink to &quot;ArrayList 和 LinkedList 的区别&quot;">​</a></h3><blockquote><p>开发中基本不使用LinkedList</p></blockquote><table><thead><tr><th>特性</th><th><code>ArrayList</code></th><th><code>LinkedList</code></th></tr></thead><tbody><tr><td>数据结构</td><td>动态数组</td><td>双向链表</td></tr><tr><td>内存占用</td><td>内存连续，开销小</td><td>每个元素有额外的指针开销，内存不连续</td></tr><tr><td>随机访问</td><td>快速（O(1)）</td><td>慢（O(n)），需要遍历链表</td></tr><tr><td>插入/删除性能</td><td>慢（O(n)），需要移动元素</td><td>快（O(1)），只需修改指针</td></tr><tr><td>迭代器性能</td><td>快（基于数组）</td><td>慢（基于链表）</td></tr><tr><td>适用场景</td><td>频繁随机访问，少量插入/删除操作</td><td>频繁插入/删除操作，少量随机访问操作</td></tr><tr><td>内存使用</td><td>内存使用较少，适合存储大量数据</td><td>内存使用较多，适合频繁变动的数据结构</td></tr><tr><td>线程安全</td><td>非线程安全，需手动同步</td><td>非线程安全，需手动同步</td></tr><tr><td>主要方法</td><td><code>get()</code>, <code>set()</code>, <code>add()</code>, <code>remove()</code></td><td><code>get()</code>, <code>set()</code>, <code>add()</code>, <code>remove()</code>, <code>addFirst()</code>, <code>addLast()</code></td></tr></tbody></table><h3 id="arraylist的扩容机制" tabindex="-1">ArrayList的扩容机制 <a class="header-anchor" href="#arraylist的扩容机制" aria-label="Permalink to &quot;ArrayList的扩容机制&quot;">​</a></h3><ol><li><strong>扩容时机</strong>：当添加元素时，如果当前容量已满，则触发扩容。</li><li><strong>扩容策略</strong>：通常是将容量增加到原来的1.5</li><li><strong>实现原理</strong>：创建一个新的数组，将原数组的元素复制到新数组中，然后将新数组赋值给原数组引用。</li><li><strong>性能影响</strong>：扩容操作是O(n)，因为需要复制所有元素，但通常不会频繁发生。</li></ol><h3 id="hashmap-hashtable-linkedhashmap的区别" tabindex="-1">HashMap,hashTable,LinkedHashMap的区别 <a class="header-anchor" href="#hashmap-hashtable-linkedhashmap的区别" aria-label="Permalink to &quot;HashMap,hashTable,LinkedHashMap的区别&quot;">​</a></h3><table><thead><tr><th>特性</th><th><code>HashMap</code></th><th><code>Hashtable</code></th><th><code>LinkedHashMap</code></th></tr></thead><tbody><tr><td>是否线程安全</td><td>❌ 否</td><td>✅ 是（方法加了 <code>synchronized</code>）</td><td>❌ 否</td></tr><tr><td>效率（单线程）</td><td>✅ 高</td><td>❌ 低</td><td>✅ 高</td></tr><tr><td>是否允许 <code>null</code> 键/值</td><td>✅ 允许 1 个 <code>null</code> 键 &amp; 多个值</td><td>❌ 都不允许</td><td>✅ 允许，行为与 <code>HashMap</code> 一致</td></tr><tr><td>元素是否有序</td><td>❌ 无序</td><td>❌ 无序</td><td>✅ 有序（插入顺序 or 访问顺序）</td></tr><tr><td>替代建议</td><td>推荐使用</td><td>不推荐（JDK 1.0 遗产）</td><td>用于需要保序的场景</td></tr><tr><td>底层结构</td><td>哈希表 + 链表 / 红黑树（JDK8）</td><td>哈希表</td><td>哈希表 + 双向链表</td></tr><tr><td>线程安全替代方案</td><td><code>ConcurrentHashMap</code></td><td>❌（老旧）</td><td>用 <code>Collections.synchronizedMap()</code></td></tr></tbody></table><h3 id="hashmap的底层实现" tabindex="-1">HashMap的底层实现 <a class="header-anchor" href="#hashmap的底层实现" aria-label="Permalink to &quot;HashMap的底层实现&quot;">​</a></h3><table><thead><tr><th>特性</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>冲突结构</td><td>链表</td><td>链表 + 红黑树</td></tr><tr><td>链表插入方式</td><td>头插法（快但容易反转）</td><td>尾插法（防止死循环）</td></tr><tr><td>是否线程安全</td><td>❌ 否</td><td>❌ 否</td></tr><tr><td>扩容机制</td><td>2 倍扩容 + 重新 hash</td><td>同上，但优化了 hash 分布</td></tr><tr><td>树化条件</td><td>❌ 不支持</td><td>链表长度 &gt; 8 且 table 长度 ≥ 64</td></tr><tr><td>死循环风险</td><td>✅ 有，在多线程中可能出现</td><td>❌ 无头插法，避免链表反转</td></tr></tbody></table><blockquote><p>HashMap中key存放到数组中，value存放到链表或红黑树中。 JDK1.8 版本的 HashMap 在链表长度超过 8 且数组长度超过 64 时会将链表转换为红黑树， 将链表换成红⿊树前会判断，如果当前数组的⻓度⼩于 64,会优先数组扩容，⽽不是 换为红⿊树。</p></blockquote><h3 id="hashmap的put过程" tabindex="-1">HashMap的put过程 <a class="header-anchor" href="#hashmap的put过程" aria-label="Permalink to &quot;HashMap的put过程&quot;">​</a></h3><p><img src="'+o+'" alt="HashMap的put流程"></p>',14)]))}const m=d(h,[["render",s]]);export{b as __pageData,m as default};
