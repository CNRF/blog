import{_ as a,c as i,o as n,a3 as e}from"./chunks/framework.Dohe277V.js";const l="/blog/assets/c1da6b3565224c1688d0d6e6dfa4f377.NrO2JdyJ.png",E=JSON.parse('{"title":"07.JUC初解","description":"","frontmatter":{"title":"07.JUC初解","tags":["java","多线程"],"categories":["java","多线程"]},"headers":[],"relativePath":"java/02.多线程和高并发/07.JUC初解.md","filePath":"java/02.多线程和高并发/07.JUC初解.md","lastUpdated":1742440256000}'),t={name:"java/02.多线程和高并发/07.JUC初解.md"};function r(p,s,h,o,k,d){return n(),i("div",null,s[0]||(s[0]=[e('<h2 id="overview" tabindex="-1">overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;overview&quot;">​</a></h2><p><img src="'+l+`" alt="JUC相关类总结 .png"></p><p>以下是对该链接内容的总结，并为你生成了一篇全新的文章，内容涉及 Java 并发编程及其在多线程开发中的重要工具类。</p><hr><h2 id="深入理解-java-并发工具包-juc" tabindex="-1">深入理解 Java 并发工具包（JUC） <a class="header-anchor" href="#深入理解-java-并发工具包-juc" aria-label="Permalink to &quot;深入理解 Java 并发工具包（JUC）&quot;">​</a></h2><p>Java 提供了丰富的并发编程支持，尤其是通过 <code>java.util.concurrent</code> 包（简称 JUC）来实现。JUC 包含了一些非常强大的工具类，它们帮助开发者在多线程编程中高效地管理线程池、同步机制、线程安全的数据结构等，避免了许多传统并发编程中的常见问题，如死锁、竞态条件等。</p><p>在本篇文章中，我们将对 JUC 中的一些重要工具进行总结和分析，帮助大家全面理解并发编程的核心组件。</p><h3 id="_1-java-并发编程概述" tabindex="-1">1. <strong>Java 并发编程概述</strong> <a class="header-anchor" href="#_1-java-并发编程概述" aria-label="Permalink to &quot;1. **Java 并发编程概述**&quot;">​</a></h3><p>Java 并发编程使得我们能够在多个线程之间共享资源、协作完成任务。传统的多线程管理方式主要依赖 <code>Thread</code> 类和 <code>synchronized</code> 关键字，但是随着 Java 语言的演进，<code>java.util.concurrent</code> 包提供了更高效、灵活的解决方案。</p><p>JUC 包提供了以下几类常用工具：</p><ul><li><strong>线程池</strong>：高效管理线程的创建与销毁，避免频繁创建线程带来的性能损失。</li><li><strong>同步工具</strong>：如 <code>ReentrantLock</code>、<code>Condition</code> 等，可以提供更精细的锁机制。</li><li><strong>线程安全的数据结构</strong>：如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 等，能够确保线程间数据访问的安全性。</li><li><strong>并发控制工具</strong>：如 <code>CountDownLatch</code>、<code>CyclicBarrier</code> 等，用于线程之间的协调和控制。</li></ul><h3 id="_2-线程池" tabindex="-1">2. <strong>线程池</strong> <a class="header-anchor" href="#_2-线程池" aria-label="Permalink to &quot;2. **线程池**&quot;">​</a></h3><p>线程池是管理线程的核心工具，JUC 提供了 <code>Executor</code> 框架来简化线程管理。线程池通过预创建一定数量的线程并复用这些线程，避免了频繁创建和销毁线程的开销。</p><h4 id="核心接口" tabindex="-1">核心接口 <a class="header-anchor" href="#核心接口" aria-label="Permalink to &quot;核心接口&quot;">​</a></h4><ul><li><strong>Executor</strong>：用于执行任务的接口。</li><li><strong>ExecutorService</strong>：继承自 <code>Executor</code>，提供了更为丰富的功能，特别是用于任务的提交和管理。</li></ul><h4 id="线程池实现" tabindex="-1">线程池实现 <a class="header-anchor" href="#线程池实现" aria-label="Permalink to &quot;线程池实现&quot;">​</a></h4><ul><li><strong>ThreadPoolExecutor</strong>：最常用的线程池实现类，提供了精细的控制。</li><li><strong>ScheduledThreadPoolExecutor</strong>：用于定时或周期性任务的执行。</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ExecutorService executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newFixedThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">executor.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">submit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello from thread pool&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_3-锁机制" tabindex="-1">3. <strong>锁机制</strong> <a class="header-anchor" href="#_3-锁机制" aria-label="Permalink to &quot;3. **锁机制**&quot;">​</a></h3><p>JUC 提供了比传统 <code>synchronized</code> 更强大的锁机制。<code>ReentrantLock</code> 是常用的显式锁，它支持公平锁、可中断锁等特性，相比传统的 <code>synchronized</code>，它提供了更大的灵活性和可控性。</p><h4 id="关键类" tabindex="-1">关键类 <a class="header-anchor" href="#关键类" aria-label="Permalink to &quot;关键类&quot;">​</a></h4><ul><li><strong>ReentrantLock</strong>：提供可重入的独占锁，支持公平性、锁的中断等。</li><li><strong>ReadWriteLock</strong>：提供读写锁，在高并发读取场景下有显著性能优势。</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ReentrantLock lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lock.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 需要同步的代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        lock.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="condition" tabindex="-1">Condition <a class="header-anchor" href="#condition" aria-label="Permalink to &quot;Condition&quot;">​</a></h4><p><code>Condition</code> 类允许线程在满足某个条件时进行等待和通知，比传统的 <code>Object.wait()</code> 和 <code>notify()</code> 更加灵活。</p><h3 id="_4-并发容器" tabindex="-1">4. <strong>并发容器</strong> <a class="header-anchor" href="#_4-并发容器" aria-label="Permalink to &quot;4. **并发容器**&quot;">​</a></h3><p>JUC 提供了一些线程安全的集合类，确保在多线程环境下的高效访问。这些容器能够帮助我们避免传统集合类的并发问题。</p><h4 id="关键类-1" tabindex="-1">关键类 <a class="header-anchor" href="#关键类-1" aria-label="Permalink to &quot;关键类&quot;">​</a></h4><ul><li><strong>ConcurrentHashMap</strong>：线程安全的哈希映射实现，支持高并发读写。</li><li><strong>CopyOnWriteArrayList</strong>：线程安全的 List 实现，适用于读多写少的场景。</li><li><strong>BlockingQueue</strong>：线程安全的队列，支持阻塞操作。</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ConcurrentHashMap&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; map </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ConcurrentHashMap&lt;&gt;();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">put</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;key&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_5-同步工具类" tabindex="-1">5. <strong>同步工具类</strong> <a class="header-anchor" href="#_5-同步工具类" aria-label="Permalink to &quot;5. **同步工具类**&quot;">​</a></h3><p>JUC 提供了多种工具类，用于线程间的协调和控制，常见的有：</p><ul><li><strong>CountDownLatch</strong>：一个同步工具，允许一个或多个线程等待直到其他线程完成一系列操作。</li><li><strong>CyclicBarrier</strong>：允许一组线程在某个点上相互等待，直到所有线程到达同步点后再继续执行。</li><li><strong>Semaphore</strong>：用于限制同时访问某个资源的线程数量，常用于流量控制。</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CountDownLatch latch </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CountDownLatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">latch.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当前线程等待直到 latch 计数为 0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_6-fork-join-框架" tabindex="-1">6. <strong>Fork/Join 框架</strong> <a class="header-anchor" href="#_6-fork-join-框架" aria-label="Permalink to &quot;6. **Fork/Join 框架**&quot;">​</a></h3><p><code>ForkJoinPool</code> 是 JUC 中为并行计算设计的一个框架，它能够高效地分解大任务，使用多个线程并行执行子任务，最后将结果合并。</p><h4 id="关键类-2" tabindex="-1">关键类 <a class="header-anchor" href="#关键类-2" aria-label="Permalink to &quot;关键类&quot;">​</a></h4><ul><li><strong>ForkJoinPool</strong>：管理 Fork/Join 任务的线程池。</li><li><strong>RecursiveTask</strong>：表示一个可以返回结果的任务。</li><li><strong>RecursiveAction</strong>：表示一个没有返回值的任务。</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ForkJoinPool pool </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ForkJoinPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RecursiveTask&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; task </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RecursiveTask&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    protected</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">compute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 任务分解和合并</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pool.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invoke</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(task);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_7-总结与最佳实践" tabindex="-1">7. <strong>总结与最佳实践</strong> <a class="header-anchor" href="#_7-总结与最佳实践" aria-label="Permalink to &quot;7. **总结与最佳实践**&quot;">​</a></h3><p>Java 并发工具包提供了一整套高效、灵活的并发编程解决方案，帮助开发者避免了传统多线程编程中的很多复杂性。无论是线程池管理、锁机制、线程安全容器，还是线程协调工具，JUC 都提供了比传统方式更为高效和可靠的方案。</p><p>在实际开发中，我们可以根据不同的场景选择合适的工具：</p><ul><li>使用线程池来管理和复用线程。</li><li>在需要精确控制线程执行顺序时，使用 <code>ReentrantLock</code> 和 <code>Condition</code>。</li><li>在处理高并发场景时，选择合适的并发容器，如 <code>ConcurrentHashMap</code> 或 <code>BlockingQueue</code>。</li><li>使用 <code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 进行线程间的同步。</li></ul><p>通过合理运用这些工具，能够大大简化并发编程的复杂度，提升应用程序的性能和可维护性。</p>`,44)]))}const g=a(t,[["render",r]]);export{E as __pageData,g as default};
