import{_ as t,D as e,c as d,o as p,a3 as r,m as s,H as a,a as i,w as n}from"./chunks/framework.DpPtyC7-.js";const g="/blog/assets/32dd5335f7636be72c873db8c9534597_MD5.B_MtYcmQ.png",b="/blog/assets/34905482aa93560dca725114eca93cf2_MD5.CBzfd3v5.png",u="/blog/assets/3bf73282c6ccb3c4945dcf0d00ace1fd_MD5.DaHZwris.png",k="/blog/assets/26fb0ae4d0cbda867c7a7ba8e8f5163c_MD5.u5Z0FIPN.png",m="/blog/assets/4e3bfd9e4480fa0517bbe81b7f152032_MD5.XVfha9rZ.png",E="/blog/assets/d3ee0d36e831b172e853b6c7412f14be_MD5.C1vmsgoX.png",h="/blog/assets/ae654de1c34482a8ba376ea904ee43e7_MD5.9q003UJp.png",f="/blog/assets/fa2b52f659c9f444430275d6af40f360_MD5.zYenrNRu.png",y="/blog/assets/a6856b5fc9bdaa8bbb406d3adc460671_MD5.B0tffbx2.png",D="/blog/assets/93731188505457d7942751721ee1281a_MD5.Bu3Y7vkG.png",C="/blog/assets/a1324bb0510a93ef5b1483c5e45cd858_MD5.d3_WiMVz.png",A="/blog/assets/21c5c90083399f7ae795e8714e694f94_MD5.BHIMVcsk.png",q="/blog/assets/d8e3ce7eaa8efbfea43f8e23c39e33aa_MD5.DpLBJV6a.png",B="/blog/assets/1744528278318.DNYDr_yW.png",M="/blog/assets/1744528014061.Dq3enavH.png",I="/blog/assets/1744528181968.DoWCbBou.png",T="/blog/assets/1744528222830._0YX3Dqs.png",P="/blog/assets/3e73ce2815e80486f445bbe1ad0109a5_MD5.BJZRP-H6.png",S="/blog/assets/7b583fe3201827a32025a1ad73b61c36_MD5.33w6xduU.png",U=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"database/01.mysql/08.MySQL的事务.md","filePath":"database/01.mysql/08.MySQL的事务.md","lastUpdated":1755051651000}'),x={name:"database/01.mysql/08.MySQL的事务.md"};function R(L,l,F,N,v,O){const o=e("font");return p(),d("div",null,[l[43]||(l[43]=r('<p><img src="'+g+'" alt=""></p><h2 id="为什么要有事务" tabindex="-1">为什么要有事务 <a class="header-anchor" href="#为什么要有事务" aria-label="Permalink to &quot;为什么要有事务&quot;">​</a></h2><p>**数据库引入事务的主要目的是事务会把数据库会从一种一致状态转换到另一种一致状态，数据库提交工作时可以确保要么所有修改都保存，要么所有修改都不保存。 **</p><h3 id="事务的四大特性-acid" tabindex="-1">事务的四大特性（ACID） <a class="header-anchor" href="#事务的四大特性-acid" aria-label="Permalink to &quot;事务的四大特性（ACID）&quot;">​</a></h3><ul><li><strong>A(Atomicity) 原子性</strong></li><li><strong>C(Consistency) 一致性</strong></li><li><strong>I(Isolation) 隔离性</strong></li><li><strong>D(Durability) 持久性</strong></li></ul><h4 id="a-atomicity-原子性" tabindex="-1">A(Atomicity) 原子性 <a class="header-anchor" href="#a-atomicity-原子性" aria-label="Permalink to &quot;A(Atomicity) 原子性&quot;">​</a></h4>',6)),s("p",null,[l[1]||(l[1]=i("原子性是",-1)),l[2]||(l[2]=s("strong",null,"整个数据库事务是不可分割的工作单位",-1)),l[3]||(l[3]=i("，只有",-1)),a(o,{color:"red"},{default:n(()=>l[0]||(l[0]=[i(" 事务中的所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL执行失败，已经执行成功的SQL语句也必须撤销，回到执行事务的之前的状态",-1)])),_:1,__:[0]}),l[4]||(l[4]=i("。",-1))]),l[44]||(l[44]=s("h4",{id:"c-consistency-一致性",tabindex:"-1"},[i("C(Consistency) 一致性 "),s("a",{class:"header-anchor",href:"#c-consistency-一致性","aria-label":'Permalink to "C(Consistency) 一致性"'},"​")],-1)),s("p",null,[l[6]||(l[6]=i("一致性是指事务将数据库从一种一致性状态变为下一种一致性状态。",-1)),a(o,{color:"red"},{default:n(()=>l[5]||(l[5]=[i(" 在事务开始之前和之后，数据库的完整性约束没有被破坏。",-1)])),_:1,__:[5]})]),l[45]||(l[45]=s("h4",{id:"i-isolation-隔离性",tabindex:"-1"},[i("I(Isolation) 隔离性 "),s("a",{class:"header-anchor",href:"#i-isolation-隔离性","aria-label":'Permalink to "I(Isolation) 隔离性"'},"​")],-1)),s("p",null,[l[8]||(l[8]=i("隔离性要求",-1)),a(o,{color:"red"},{default:n(()=>l[7]||(l[7]=[i("每个读写事务对其他事务的操作对象能相互分离。",-1)])),_:1,__:[7]})]),l[46]||(l[46]=s("h4",{id:"d-durability-持久性",tabindex:"-1"},[i("D(Durability) 持久性 "),s("a",{class:"header-anchor",href:"#d-durability-持久性","aria-label":'Permalink to "D(Durability) 持久性"'},"​")],-1)),s("p",null,[l[10]||(l[10]=i("持久性指",-1)),a(o,{color:"red"},{default:n(()=>l[9]||(l[9]=[i("事务一旦提交，其结果就是永久性的。",-1)])),_:1,__:[9]})]),l[47]||(l[47]=s("h2",{id:"事务的实现",tabindex:"-1"},[i("事务的实现 "),s("a",{class:"header-anchor",href:"#事务的实现","aria-label":'Permalink to "事务的实现"'},"​")],-1)),l[48]||(l[48]=s("p",null,"事务的实现就是如何实现ACID特性，下面一图下概况下：",-1)),l[49]||(l[49]=s("p",null,[s("img",{src:b,alt:""})],-1)),a(o,{color:"red"},{default:n(()=>l[11]||(l[11]=[i("事务的实现通过 redo_log 和 undo_log， 以及锁实现，锁实现事务的",-1)])),_:1,__:[11]}),a(o,{color:"yellow"},{default:n(()=>l[12]||(l[12]=[i("redo_log 实现持久化和原子性，而undo_log实现一致性，二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。",-1)])),_:1,__:[12]}),l[50]||(l[50]=s("h3",{id:"redo-log-重做日志",tabindex:"-1"},[i("redo log 重做日志 "),s("a",{class:"header-anchor",href:"#redo-log-重做日志","aria-label":'Permalink to "redo log 重做日志"'},"​")],-1)),s("p",null,[l[14]||(l[14]=s("strong",null,"redo_log 重做日志上面已经提到实现持久化和原子性",-1)),l[15]||(l[15]=i("，重做日志由两部分组成，",-1)),a(o,{color:"red"},{default:n(()=>l[13]||(l[13]=[i("一是内存中的重做日志缓存(redo log buffer)，这部分是容易丢失的。二是重做日志文件(redo log file)，这部分是持久的",-1)])),_:1,__:[13]})]),l[51]||(l[51]=s("h4",{id:"redo-log更新流程",tabindex:"-1"},[i("redo log更新流程 "),s("a",{class:"header-anchor",href:"#redo-log更新流程","aria-label":'Permalink to "redo log更新流程"'},"​")],-1)),l[52]||(l[52]=s("p",null,"redo log的更新流程如下图，以一次Update 操作为例。",-1)),l[53]||(l[53]=s("p",null,[s("img",{src:u,alt:""})],-1)),l[54]||(l[54]=s("ol",null,[s("li",null,"执行update操作。"),s("li",null,"先将原始数据从磁盘读取到内存，修改内存中的数据。"),s("li",null,"生成一条重做日志写入redo log buffer，记录数据被修改后的值。"),s("li",null,"当事务提交时，需要将redo log buffer中的内容刷新到redo log file。"),s("li",null,"事务提交后，也会将内存中修改数据的值写入磁盘。")],-1)),s("blockquote",null,[s("p",null,[l[17]||(l[17]=i("为了确保每次日志都写入重做日志文件，",-1)),a(o,{color:"red"},{default:n(()=>l[16]||(l[16]=[i("InnoDB存储引擎会调用一次fsync操作。",-1)])),_:1,__:[16]})])]),l[55]||(l[55]=r('<h4 id="存储格式内容" tabindex="-1">存储格式内容 <a class="header-anchor" href="#存储格式内容" aria-label="Permalink to &quot;存储格式内容&quot;">​</a></h4><h5 id="mysql的binlog与redo-log区别" tabindex="-1">mysql的binlog与redo log区别 <a class="header-anchor" href="#mysql的binlog与redo-log区别" aria-label="Permalink to &quot;mysql的binlog与redo log区别&quot;">​</a></h5><ol><li>首先2者都是记录数据的改变，不同的是，binlog是记录所有数据的改变信息，而innodb的redo log只是记录所有innodb表数据的变化。</li><li>binlog是记录已经提交完毕之后的dml以及ddl sql语句，而innodb redo log是正在执行中的dml以及ddl语句</li><li>binlog可以作为恢复数据使用 ，redo log可以作为异常down机或者介质故障后的数据恢复使用</li><li>在db文件目录下，也分属于不同的日志文件中。</li></ol><h5 id="mysql的binlog与redo-log的写入方式" tabindex="-1">mysql的binlog与redo log的写入方式 <a class="header-anchor" href="#mysql的binlog与redo-log的写入方式" aria-label="Permalink to &quot;mysql的binlog与redo log的写入方式&quot;">​</a></h5><p><img src="'+k+'" alt=""></p><p>binlog是每次事务才写入，所以<strong>每个事务只会有一条日志，记录的逻辑日志，也可以说记录的就是SQL语句。</strong></p><p>redo log是事务开始就开始写入，*<strong>T1表示事务提交</strong>。<strong>记录的是物理格式日志</strong>，即每个页的修改。</p><p>redo log默认是以block(块)的方式为单位进行存储，每个块是512个字节。不同的数据库引擎有对应的重做日志格式，Innodb的存储管理是基于页的，所以其重做日志也是基于页的。</p><p>redo log格式:</p><p><img src="'+m+`" alt=""></p><ul><li>redo_log_type 重做日志类型</li><li>space 表空间的ID</li><li>page_no 页的偏移量</li><li>redo_log_body 存储内容</li></ul><p>执行一条插入语句，重做日志大致为:</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INSERT INTO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">|</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), offset </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> # 主键索引</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">page</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), offset </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">64</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">value</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   # 辅助索引</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="恢复机制" tabindex="-1">恢复机制 <a class="header-anchor" href="#恢复机制" aria-label="Permalink to &quot;恢复机制&quot;">​</a></h4><p><img src="`+E+'" alt=""></p><p><strong>LSN(Log Sequence Number) 日志序列号</strong>，Innodb里，LSN占8个字节，且是单调递增的，<strong>代表的含义</strong>有: 重做日志写入的总量、checkpoint的位置、页的版本。</p><p>假设在LSN=10000的时候数据库出现故障，磁盘中checkpoint为10000，表示磁盘已经刷新到10000这个序列号，当前redolog的checkpoint是13000，则需要恢复10000-13000的数据。</p><h4 id="redo-log为什么可以实现事务的原子性和持久性。" tabindex="-1">redo log为什么可以实现事务的原子性和持久性。 <a class="header-anchor" href="#redo-log为什么可以实现事务的原子性和持久性。" aria-label="Permalink to &quot;redo log为什么可以实现事务的原子性和持久性。&quot;">​</a></h4><ul><li>原子性，是redo log记录了事务期间操作的物理日志，事务提交之前，并没有写入磁盘，保存在内存里，如果事务失败，数据库磁盘不会有影响，回滚掉事务内存部分即可。</li><li>持久性，redo log 会在事务提交时将日志存储到磁盘redo log file，保证日志的持久性。</li></ul><h3 id="undo-log" tabindex="-1">undo log <a class="header-anchor" href="#undo-log" aria-label="Permalink to &quot;undo log&quot;">​</a></h3><p>redo log一旦提交意味着持久化了，但是有时候需要对其进行rollback操作，那就需要undo log。</p><p>undo log是逻辑日志，只是将数据库逻辑的恢复到原来的样子。并不能将数据库物理地恢复到执行语句或者事务之前的样子。虽然所有的逻辑修改均被取消了，但是数据结构和页本身在回滚前后可能不一样了。</p>',22)),s("p",null,[l[19]||(l[19]=i("既然是逻辑日志，可以",-1)),a(o,{color:"red"},{default:n(()=>l[18]||(l[18]=[i("理解为它存储的是SQL, 在事务中使用的每一条 INSERT 都对应了一条 DELETE，每一条 UPDATE 也都对应一条相反的 UPDATE 语句。",-1)])),_:1,__:[18]})]),l[56]||(l[56]=s("p",null,[s("img",{src:h,alt:""})],-1)),s("ul",null,[l[23]||(l[23]=s("li",null,[s("p",null,"undo log 存放在数据库内部的一个特殊段(segment)中，也叫undo段，存在于共享表空间中。")],-1)),l[24]||(l[24]=s("li",null,[s("p",null,"undo log实现了事务的一致性，可以通过undo log恢复到事务之前的逻辑状态，保证一致性。")],-1)),s("li",null,[s("p",null,[l[21]||(l[21]=i("undo log 还可以实现MVCC（Multi-Version Concurrency Control ，多版本并发控制），",-1)),a(o,{color:"red"},{default:n(()=>l[20]||(l[20]=[i("多版本并发控制其实可以通过 undo log 形成一个事务执行过程中的版本链，每一个写操作会产生一个版本，数据库发生读的并发访问时，读操作访问版本链，返回最合适的结果直接返回",-1)])),_:1,__:[20]}),l[22]||(l[22]=i(" 。从而读写操作之间没有冲突，提高了性能。",-1))])])]),l[57]||(l[57]=r('<h2 id="事务控制语句" tabindex="-1">事务控制语句 <a class="header-anchor" href="#事务控制语句" aria-label="Permalink to &quot;事务控制语句&quot;">​</a></h2><p><img src="'+f+'" alt=""></p><blockquote><p>set transaction 修改事务隔离级别，比如修改会话级别的事务:</p><p><strong>set session transaction isolation level read committed;</strong></p></blockquote><h2 id="事务隔离级别" tabindex="-1">事务隔离级别 <a class="header-anchor" href="#事务隔离级别" aria-label="Permalink to &quot;事务隔离级别&quot;">​</a></h2><p><img src="'+y+'" alt=""></p><p>四种隔离级别，按READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE顺序， 隔离级别是从低到高，<strong>InnoDB默认是REPEATABLE-READ级别，此级别在其余数据库中是会引起幻读问题， InnoDB采用Next-Key Lock锁算法避免了此问题</strong></p><h3 id="read-uncommitted" tabindex="-1">READ-UNCOMMITTED <a class="header-anchor" href="#read-uncommitted" aria-label="Permalink to &quot;READ-UNCOMMITTED&quot;">​</a></h3><p>READ-UNCOMMITTED 中文叫<strong>未提交读</strong>，即一个事务读到了另一个未提交事务修改过的数据，整个过程如下图:</p><p><img src="'+D+'" alt=""></p>',9)),a(o,{color:"red"},{default:n(()=>l[25]||(l[25]=[i("SessionA和SessionB分别开启一个事务，SessionB中的事务先将id为1的记录的name列更新为'lisi'，然后Session 中的事务再去查询这条id为1的记录，那么在未提交读的隔离级别下，查询结果由'zhangsan'变成了'lisi' ，也就是说某个事务读到了另一个未提交事务修改过的记录。但是如果SessionB中的事务稍后进行了回滚，那么SessionA中的事务相当于读到了一个不存在的数据，这种现象也称为脏读。",-1)])),_:1,__:[25]}),l[58]||(l[58]=i(" 可见READ-UNCOMMITTED是非常不安全 ",-1)),l[59]||(l[59]=s("h3",{id:"read-committed",tabindex:"-1"},[i("READ COMMITTED "),s("a",{class:"header-anchor",href:"#read-committed","aria-label":'Permalink to "READ COMMITTED"'},"​")],-1)),s("p",null,[l[27]||(l[27]=i("READ COMMITTED 中文叫",-1)),l[28]||(l[28]=s("strong",null,"已提交读，或者叫不可重复读",-1)),l[29]||(l[29]=i("。",-1)),a(o,{color:"red"},{default:n(()=>l[26]||(l[26]=[i(" 即一个事务能读到另一个已经提交事务修改后的数据，如果其他事务均对该数据进行修改并提交，该事务也能查询到最新值。",-1)])),_:1,__:[26]})]),l[60]||(l[60]=s("p",null,[s("img",{src:C,alt:""})],-1)),a(o,{color:"red"},{default:n(()=>l[30]||(l[30]=[i("SessionB 修改后，如果未提交，SessionA是读不到，但SessionB一旦提交后，SessionA即可读到SessionB修改的内容。",-1)])),_:1,__:[30]}),l[61]||(l[61]=i("不可重复读是违反事务的隔离性的。 ",-1)),l[62]||(l[62]=s("h3",{id:"repeatable-read",tabindex:"-1"},[i("REPEATABLE READ "),s("a",{class:"header-anchor",href:"#repeatable-read","aria-label":'Permalink to "REPEATABLE READ"'},"​")],-1)),s("p",null,[l[32]||(l[32]=i("REPEATABLE READ 中文叫可重复读，",-1)),a(o,{color:"red"},{default:n(()=>l[31]||(l[31]=[i(" 即事务能读到另一个已经提交的事务修改过的数据，但是第一次读过某条记录后，即使后面其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据。",-1)])),_:1,__:[31]}),l[33]||(l[33]=i(" 如下图:",-1))]),l[63]||(l[63]=r('<p><img src="'+A+'" alt=""></p><p>InnoDB默认是这种隔离级别，SessionB无论怎么修改id=1的值，SessionA读到依然是自己开启事务第一次读到的内容。</p><h4 id="可重复读为什么会产生幻读" tabindex="-1">可重复读为什么会产生幻读 <a class="header-anchor" href="#可重复读为什么会产生幻读" aria-label="Permalink to &quot;可重复读为什么会产生幻读&quot;">​</a></h4><p>在 可重复读 隔离级别下，MySQL 的存储引擎（InnoDB）会使用 <strong>行锁</strong> 来保证同一行数据在事务中不会被修改，防止不可重复读的情况发生。但是，这个隔离级别并没有锁定数据库中所有符合查询条件的记录。特别是在使用 范围查询（比如 WHERE 子句包含范围条件如 BETWEEN、&gt;、&lt;）时，其他事务仍然可以插入新的记录，符合这些条件的记录可能会在后续的查询中出现，导致查询结果集发生变化，产生幻读。</p><blockquote><p>如范围查询，a事务查询id&gt;10的记录，b事务在a事务查询的过程中插入了一条id=11的记录， 导致a事务两次查询的结果不一致。新增了一条11的记录</p></blockquote><h3 id="serializable" tabindex="-1">SERIALIZABLE <a class="header-anchor" href="#serializable" aria-label="Permalink to &quot;SERIALIZABLE&quot;">​</a></h3>',6)),s("p",null,[l[35]||(l[35]=i("SERIALIZABLE 叫串行化， 上面三种隔离级别可以进行 读-读 或者 读-写、写-读三种并发操作，而",-1)),a(o,{color:"red"},{default:n(()=>l[34]||(l[34]=[i(" SERIALIZABLE不允许读-写，写-读的并发操作",-1)])),_:1,__:[34]}),l[36]||(l[36]=i("。 如下图:",-1))]),l[64]||(l[64]=r('<p><img src="'+q+'" alt=""></p><p>SessionB 对 id=1 进行修改的时候，SessionA 读取id=1则需要等待 SessionB 提交事务。可以理解SessionB在更新的时候加了锁。</p><h2 id="事务引发的问题" tabindex="-1">事务引发的问题 <a class="header-anchor" href="#事务引发的问题" aria-label="Permalink to &quot;事务引发的问题&quot;">​</a></h2><p>我们知道MySQL是一个客户端／服务器架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（Session）。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理多个事务。</p><p>在上面我们说过事务有一个称之为隔离性的特性，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据，这样的话并发事务的执行就变成了串行化执行。</p><p>但是对串行化执行性能影响太大，我们既想保持事务的一定的隔离性，又想让服务器在处理访问同一数据的多个事务时性能尽量高些，当我们舍弃隔离性的时候，可能会带来什么样的数据问题呢？ <img src="'+B+'" alt="21048532674b4486a21b90258b046a15.png"></p><h3 id="脏读" tabindex="-1">脏读 <a class="header-anchor" href="#脏读" aria-label="Permalink to &quot;脏读&quot;">​</a></h3>',7)),s("p",null,[l[38]||(l[38]=i("脏读是指一个事务读取了另一个事务未提交的数据，",-1)),a(o,{color:"red"},{default:n(()=>l[37]||(l[37]=[i(" 如果这个未提交的事务最终回滚，那么第一个事务就读取到了一个不存在的数据。",-1)])),_:1,__:[37]}),l[39]||(l[39]=s("img",{src:M,alt:"脏读"},null,-1))]),l[65]||(l[65]=s("p",null,"1、在事务A执⾏过程中，事务A对数据资源进⾏了修改，事务B读取了事务A修改后的数据。 2、由于某些原因，事务A并没有完成提交，发⽣了RollBack操作，则事务B读取的数据就是脏数据。 这种读取到另⼀个事务未提交的数据的现象就是脏读(Dirty Read)。",-1)),l[66]||(l[66]=s("h3",{id:"不可重复读",tabindex:"-1"},[i("不可重复读 "),s("a",{class:"header-anchor",href:"#不可重复读","aria-label":'Permalink to "不可重复读"'},"​")],-1)),s("p",null,[l[41]||(l[41]=i("不可重复读是指在同一个事务中多次读取同一条记录，",-1)),a(o,{color:"red"},{default:n(()=>l[40]||(l[40]=[i(" 在这两次读取之间，其他事务对该记录进行了修改并提交了。",-1)])),_:1,__:[40]}),l[42]||(l[42]=s("img",{src:I,alt:"不可重复读"},null,-1))]),l[67]||(l[67]=r('<p>事务B读取了两次数据资源，在这两次读取的过程中事务A修改了数据，导致事务B在这两次读取出来的 数据不⼀致。</p><h3 id="幻读" tabindex="-1">幻读 <a class="header-anchor" href="#幻读" aria-label="Permalink to &quot;幻读&quot;">​</a></h3><p>在事务执行过程中，另一个事务将新记录添加到正在读取的事务中时，会发生幻读。 <img src="'+T+'" alt="幻读"> 事务B前后两次读取同⼀个范围的数据，在事务B两次读取的过程中事务A新增了数据，导致事务B后⼀ 次读取到前⼀次查询没有看到的⾏。 幻读和不可重复读有些类似，但是幻读重点强调了读取到了之前读取没有获取到的记录。</p><h2 id="分布式事务" tabindex="-1">分布式事务 <a class="header-anchor" href="#分布式事务" aria-label="Permalink to &quot;分布式事务&quot;">​</a></h2><p>分布式事务指<strong>允许多个独立的事务资源参与到一个全局的事务中。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚。</strong></p><h3 id="innodb-分布式事务" tabindex="-1">InnoDB 分布式事务 <a class="header-anchor" href="#innodb-分布式事务" aria-label="Permalink to &quot;InnoDB 分布式事务&quot;">​</a></h3><p>InnoDB 是支持分布式事务，由一个或多个资源管理器（Resource Managers），一个事务管理器(Transaction Manager)，以及一个应用程序( Application Program)组成。</p><ul><li>资源管理器（Resource Managers），提供访问事务资源的方法，一般一个数据库就是一个资源管理器。</li><li>事务管理器(Transaction Manager)，协调参与全局事务中的各个事务，需要和参与全局事务的所有资源管理器进行通信。</li><li>应用程序(Application Program) 定义事务的边界，指定全局事务中的操作。</li></ul><p><img src="'+P+'" alt=""></p><p>应用程序向一个或多个数据库执行事务操作，* <em>事务管理器进行管理事务，通过二段式提交，第一阶段所有参与的全局事务的节点都开始准备，告诉事务管理器都准备好了，可以提交了。第二阶段，事务管理器告诉每一个资源管理器是执行Commit 还是 Rollback。如果任何一个节点显示不能提交，则所有的节点被告知需要回滚</em>*。</p><h3 id="tcc分布式事务" tabindex="-1">TCC分布式事务 <a class="header-anchor" href="#tcc分布式事务" aria-label="Permalink to &quot;TCC分布式事务&quot;">​</a></h3><p><strong>InnoDB的分布式是数据库实现的, 数据库外常见的分布式事务是TCC分布式事务</strong></p><p><img src="'+S+'" alt=""></p><p>上图描述了TCC分布式事务的流程，假设电商业务中，支付后需要修改库存，积分，物流仓储的数据，如果一个失败则全部回滚。</p><p>TCC分布式事务，有三个阶段，Try，Confirm, Cancel。也就是说每个参与事务的服务都需要实现这三个接口，库存、积分、仓储都需要实现这三个接口。</p><p>第一阶段，Try，业务应用调取各个服务的Try接口，告诉他们给我预留一个商品，有人要购买，可以理解为冻结，每一步都不执行成功，只是标记更新状态。</p><p>第二阶段，Confirm，确认阶段，即事务协调器调取每个服务Confirm执行事务操作，如果某一个服务的Confirm失败，则有第三个阶段。如果成功则结束事务。</p><p>第三个阶段，Cancel，如果在第二个阶段有一个事务提交失败，则事务协调器调取所有业务的Cancel接口，回滚事务，将第一阶段冻结的商品恢复。</p>',18))])}const V=t(x,[["render",R]]);export{U as __pageData,V as default};
