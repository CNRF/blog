import{_ as t,c as l,o as s,a5 as a}from"./chunks/framework.BV-pm6eq.js";const i="/blog/assets/11.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1713283528229.Bbdf_gUZ.png",o="/blog/assets/11.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1713283547901.me2aSvew.png",r="/blog/assets/11.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1713283592757.B5tdWpYI.png",p="/blog/assets/11.%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1713283608187.BDwD_rI3.png",e="/blog/assets/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0.ftzLhQAb.png",n="/blog/assets/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%89%B9%E7%82%B9.CwezC8BN.png",E="/blog/assets/%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.BzoHpJk1.png",g="/blog/assets/%E9%93%BE%E8%A1%A8%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B.DOZbI7Zi.png",_="/blog/assets/%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B.ClKBPcXh.png",B="/blog/assets/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%BB%93%E6%9E%84.3C9ruiTs.png",P=JSON.parse('{"title":"11.常见的数据结构","description":"","frontmatter":{"title":"11.常见的数据结构","tags":["java"],"categories":["java"]},"headers":[],"relativePath":"java/01.java基础/11.常见的数据结构.md","filePath":"java/01.java基础/11.常见的数据结构.md","lastUpdated":1721520467000}'),c={name:"java/01.java基础/11.常见的数据结构.md"},u=a('<h2 id="常见的数据结构" tabindex="-1">常见的数据结构 <a class="header-anchor" href="#常见的数据结构" aria-label="Permalink to &quot;常见的数据结构&quot;">​</a></h2><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树</p><h4 id="栈" tabindex="-1">栈 <a class="header-anchor" href="#栈" aria-label="Permalink to &quot;栈&quot;">​</a></h4><ul><li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li></ul><p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p><ul><li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p></li><li><p>栈的入口、出口的都是栈的顶端位置。</p></li></ul><p><img src="'+i+'" alt="数据出栈和入栈过程"></p><p>这里两个名词需要注意：</p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul><h4 id="队列" tabindex="-1">队列 <a class="header-anchor" href="#队列" aria-label="Permalink to &quot;队列&quot;">​</a></h4><ul><li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li><li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li></ul><p><img src="'+o+'" alt="队列出队和入队过程"></p><h4 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h4><ul><li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li></ul><p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>查找元素快：通过索引，可以快速访问指定位置的元素</li></ul><p><img src="'+r+'" alt="数组的结构"></p><ul><li><p>增删元素慢</p></li><li><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图 <img src="'+p+'" alt="数组添加指定索引的元素"></p></li><li><p>**指定索引位置删除元素：**需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图</p></li></ul><p><img src="'+e+'" alt="数组删除指定元素"></p><h4 id="链表" tabindex="-1">链表 <a class="header-anchor" href="#链表" aria-label="Permalink to &quot;链表&quot;">​</a></h4><ul><li><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。</p><p><img src="'+n+'" alt="单链表特点"></p></li></ul><p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p><p><img src="'+E+'" alt="链表查找过程"></p></li><li><p>增删元素快：</p><ul><li>增加元素：只需要修改连接下个元素的地址即可。</li></ul><p><img src="'+g+'" alt="链表添加元素过程"></p><ul><li>删除元素：只需要修改连接下个元素的地址即可。</li></ul><p><img src="'+_+'" alt="链表删除元素过程"></p></li></ul><h4 id="红黑树" tabindex="-1">红黑树 <a class="header-anchor" href="#红黑树" aria-label="Permalink to &quot;红黑树&quot;">​</a></h4><ul><li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li></ul><p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p><p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p><p>如图：</p><p><img src="'+B+'" alt="红黑树结构"></p><p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p><p>红黑树的约束:</p><ol><li><p>节点可以是红色的或者黑色的</p></li><li><p>根节点是黑色的</p></li><li><p>叶子节点(特指空节点)是黑色的</p></li><li><p>每个红色节点的子节点都是黑色的</p></li><li><p>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</p></li></ol><p>红黑树的特点:</p><p>速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p>',36),A=[u];function h(d,m,b,f,q,k){return s(),l("div",null,A)}const D=t(c,[["render",h]]);export{P as __pageData,D as default};
