import{_ as n,c as i,a3 as a,o as t}from"./chunks/framework.Bpx1IrZ-.js";const r="/blog/assets/synchronize%E9%94%81%E5%AD%97%E8%8A%82%E7%A0%81.C5eNI1Ik.png",e="/blog/assets/%E5%AF%B9%E8%B1%A1%E7%9B%91%E8%A7%86%E5%99%A8%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%85%B3%E7%B3%BB.BloOVXvw.png",E=JSON.parse('{"title":"04.synchronize关键字","description":"","frontmatter":{"title":"04.synchronize关键字","tags":["java","多线程"],"categories":["java","多线程"]},"headers":[],"relativePath":"java/02.多线程和高并发/04.synchronize关键字.md","filePath":"java/02.多线程和高并发/04.synchronize关键字.md","lastUpdated":1737084814000}'),l={name:"java/02.多线程和高并发/04.synchronize关键字.md"};function o(p,s,h,g,c,d){return t(),i("div",null,s[0]||(s[0]=[a(`<h2 id="synchronized-的对象锁和类锁-深入理解" tabindex="-1">Synchronized 的对象锁和类锁：深入理解 <a class="header-anchor" href="#synchronized-的对象锁和类锁-深入理解" aria-label="Permalink to &quot;Synchronized 的对象锁和类锁：深入理解&quot;">​</a></h2><p><strong>Synchronized</strong> 关键字是 Java 中用于实现同步的重要机制，它可以作用于 <strong>方法</strong> 和 <strong>代码块</strong> 两种地方，用于解决多线程并发访问导致的安全问题。</p><h3 id="对象锁-细粒度同步" tabindex="-1">对象锁：细粒度同步 <a class="header-anchor" href="#对象锁-细粒度同步" aria-label="Permalink to &quot;对象锁：细粒度同步&quot;">​</a></h3><p><strong>对象锁</strong> 的作用范围是 <strong>对象</strong>，意味着只有持有该对象锁的线程才能访问该对象的状态。它通常用于同步 <strong>实例方法</strong> 和 **代码块 **，确保每次只有一个线程执行这些代码，从而防止数据竞争和不一致性。</p><p>例如，考虑以下代码：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> synchronized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在这个例子中，<code>increment()</code> 方法被 <code>synchronized</code> 关键字修饰，因此它是一个 <strong>同步方法</strong> 。这意味着每次只有一个线程可以执行该方法。当一个线程调用 <code>increment()</code> 方法时，它会先获取该方法的锁。如果另一个线程试图同时调用该方法，它将被阻塞，直到第一个线程释放锁。</p><p><strong>对象锁的优点:</strong></p><ul><li>它是 Java 中最简单的同步机制。</li><li>易于理解和使用。</li><li>在 <strong>单一对象</strong> 的访问场景中，它能很好地保证数据的完整性。</li></ul><p><strong>对象锁的缺点:</strong></p><ul><li>可能导致性能下降，因为每次只有一个线程可以执行同步方法或代码块。</li><li>容易造成 <strong>死锁</strong>，如果两个线程相互持有对方的锁。</li></ul><h3 id="类锁-粗粒度同步" tabindex="-1">类锁：粗粒度同步 <a class="header-anchor" href="#类锁-粗粒度同步" aria-label="Permalink to &quot;类锁：粗粒度同步&quot;">​</a></h3><p><strong>类锁</strong> 的作用范围是 <strong>类</strong>，意味着只有持有该类锁的线程才能访问该类中所有对象的静态成员。它通常用于同步 <strong>静态方法</strong> 和 * <em>代码块</em>*，以及多个对象的 <strong>创建</strong> 和 <strong>初始化</strong> 过程。</p><p>例如，考虑以下代码：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Singleton instance;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Singleton </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Singleton</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> instance;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在这个例子中，<code>getInstance()</code> 方法被 <code>synchronized</code> 关键字修饰，并且它是静态的。这意味着每次只有一个线程可以执行该方法。当一个线程调用 <code>getInstance()</code> 方法时，它会先获取该方法的锁。如果另一个线程试图同时调用该方法，它将被阻塞，直到第一个线程释放锁。</p><p><strong>类锁的优点:</strong></p><ul><li>可以用于同步 <strong>静态成员</strong> 的访问，确保多个线程对静态成员的访问操作互斥。</li><li>可以用于同步多个对象的创建过程，防止创建多个实例。</li></ul><p><strong>类锁的缺点:</strong></p><ul><li>会限制对 <strong>静态成员</strong> 的访问，因为每次只有一个线程可以访问静态成员。</li><li>可能导致性能下降，因为每次只有一个线程可以执行同步方法或代码块。</li></ul><h3 id="对象锁与类锁的区别" tabindex="-1">对象锁与类锁的区别 <a class="header-anchor" href="#对象锁与类锁的区别" aria-label="Permalink to &quot;对象锁与类锁的区别&quot;">​</a></h3><p><strong>对象锁</strong> 和 <strong>类锁</strong> 的主要区别在于它们的作用范围不同：</p><ul><li><strong>对象锁</strong> 作用于 <strong>对象</strong>，用于同步 <strong>实例方法</strong> 和 <strong>代码块</strong>，<strong>保护</strong> 的是 <strong>对象</strong> 的状态。</li><li><strong>类锁</strong> 作用于 <strong>类</strong>，用于同步 <strong>静态方法</strong> 和 <strong>代码块</strong>，<strong>保护</strong> 的是 <strong>静态成员</strong> 和 <strong>对象创建</strong> 过程。</li></ul><p><strong>形象的比喻：</strong></p><ul><li>将对象锁想象成一个房间的门锁，只有持有钥匙的人才能进入房间。</li><li>将类锁想象成一栋楼的大门锁，只有持有钥匙的人才能进入整栋楼。</li></ul><p><strong>选择使用对象锁还是类锁取决于具体的同步需求：</strong></p><ul><li>如果需要同步 <strong>单一对象</strong> 的访问，则使用 <strong>对象锁</strong>。</li><li>如果需要同步 <strong>静态成员</strong> 的访问，或者需要同步多个对象的 <strong>创建</strong> 和 <strong>初始化</strong> 过程，则使用 <strong>类锁</strong>。</li></ul><p><strong>需要注意的是，</strong> 使用 <code>synchronized</code> 关键字会带来一些性能开销，因此应尽量避免过度使用。在 Java 5 中，引入了 * <em>ReentrantLock</em>* 类，它是一种更高级的同步机制，可以提供更高的性能和灵活性。</p><h2 id="synchronized-原理分析" tabindex="-1">Synchronized 原理分析 <a class="header-anchor" href="#synchronized-原理分析" aria-label="Permalink to &quot;Synchronized 原理分析&quot;">​</a></h2><p><strong>Synchronized</strong> 是 Java 中用于实现同步的重要机制，它可以作用于 <strong>方法</strong> 和 <strong>代码块</strong> 两种地方，用于解决多线程并发访问导致的安全问题。其底层实现是基于 <strong>监视器</strong>（Monitor）的机制。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SynchronizedDemo2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Object object </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> method1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (object) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        method2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> method2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><blockquote><p>javac SynchronizedDemo2.java</p><p>javap -verbose SynchronizedDemo2.class</p></blockquote><p><img src="`+r+'" alt="synchronize锁字节码"></p><p><code>Monitorenter</code>和<code>Monitorexit</code>指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联， 而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的Monitor锁的所有权的时候， <code>monitorenter</code>指令会发生如下3中情况之一</p><ol><li>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li><li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加</li><li>这把锁已经被别的线程获取了，等待锁释放</li></ol><p><code>monitorexit</code> 指令：释放对于monitor的所有权，释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权，如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁。</p><p>下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系： <img src="'+e+`" alt="对象监视器和线程状态关系"></p><h3 id="监视器-monitor" tabindex="-1">监视器（Monitor） <a class="header-anchor" href="#监视器-monitor" aria-label="Permalink to &quot;监视器（Monitor）&quot;">​</a></h3><p><strong>监视器</strong>（Monitor）是一种用于实现同步的机制，它由 <strong>锁</strong>（Lock）和 <strong>条件变量</strong>（Condition Variable）组成。</p><ul><li><strong>锁</strong>（Lock）用于保证每次只有一个线程执行同步代码块或方法。</li><li><strong>条件变量</strong>（Condition Variable）用于等待特定条件满足的线程。</li></ul><p><strong>监视器</strong> 提供了以下原子操作：</p><ul><li><code>acquire()</code>: 获取锁。如果锁已经被其他线程持有，则当前线程将被阻塞，直到锁被释放。</li><li><code>release()</code>: 释放锁。</li><li><code>wait()</code>: 等待特定条件满足。在调用 <code>wait()</code> 之前，必须先获取锁。</li><li><code>notify()</code>: 唤醒等待的线程。</li><li><code>notifyAll()</code>: 唤醒所有等待的线程。</li></ul><h3 id="synchronized-的实现" tabindex="-1">Synchronized 的实现 <a class="header-anchor" href="#synchronized-的实现" aria-label="Permalink to &quot;Synchronized 的实现&quot;">​</a></h3><p><strong>Synchronized</strong> 的实现是基于 <strong>对象头</strong>（Object Header）中的 <strong>锁标志</strong>（Lock Flag）来实现的。</p><p><strong>对象头</strong> 是 Java 对象在内存中布局的第一部分，它包含了一些用于管理对象信息的字段，例如：</p><ul><li><strong>哈希码</strong>（HashCode）</li><li><strong>GC 信息</strong>（GC Information）</li><li><strong>锁标志</strong>（Lock Flag）</li><li><strong>监视器</strong>（Monitor）</li></ul><p><strong>锁标志</strong> 是一个 16 位的字段，它用来指示对象的同步状态。锁标志的低 15 位用于存储 <strong>偏向锁</strong>（Biased Lock）的信息，高位用于存储 <strong>锁拥有者</strong>（Lock Owner）的信息。</p><p><strong>偏向锁</strong> 是一种用于提高性能的优化机制。当一个线程频繁地访问同一个对象时，Java 会将该对象的锁升级为 <strong>偏向锁</strong>。持有 **偏向锁 ** 的线程可以直接获取锁，而无需竞争。</p><p><strong>锁拥有者</strong> 是指当前持有该对象锁的线程。如果锁没有被任何线程持有，则 <strong>锁拥有者</strong> 为 <code>null</code>。</p><h3 id="synchronized-的使用方式" tabindex="-1">Synchronized 的使用方式 <a class="header-anchor" href="#synchronized-的使用方式" aria-label="Permalink to &quot;Synchronized 的使用方式&quot;">​</a></h3><p><strong>Synchronized</strong> 可以通过以下两种方式使用：</p><ul><li><strong>同步方法</strong>：使用 <code>synchronized</code> 关键字修饰方法。</li><li><strong>同步代码块</strong>：在代码块中使用 <code>synchronized</code> 关键字。</li></ul><p><strong>同步方法</strong> 和 <strong>同步代码块</strong> 的作用范围相同，都是同步 <strong>方法</strong> 或 <strong>代码块</strong> 内部的代码。但是，<strong>同步方法</strong> 的锁对象是 * <em>调用该方法的对象</em>*，而 <strong>同步代码块</strong> 的锁对象可以是任意对象。</p><h3 id="synchronized-的性能问题" tabindex="-1">Synchronized 的性能问题 <a class="header-anchor" href="#synchronized-的性能问题" aria-label="Permalink to &quot;Synchronized 的性能问题&quot;">​</a></h3><p><strong>Synchronized</strong> 会带来一些性能开销，主要体现在以下几个方面：</p><ul><li><strong>竞争锁</strong>：当多个线程竞争同一把锁时，需要进行 CAS 操作，这会带来额外的开销。</li><li><strong>锁膨胀</strong>：Java 会对频繁使用的锁进行 <strong>锁膨胀</strong>（Lock Inflation），以提高性能。但是，锁膨胀也会带来额外的开销。</li><li><strong>全局暂停</strong>：当一个线程持有锁时，其他线程试图获取锁时，会进入阻塞状态，导致其他线程无法执行，这会造成 <strong>全局暂停</strong>（Global Pause）。</li></ul><p><strong>为了避免 Synchronized 带来的性能问题，可以考虑使用其他同步机制，例如 <strong>ReentrantLock</strong> 或 <strong>Semaphores</strong>。</strong></p><h2 id="synchronized可重入和可见性" tabindex="-1">Synchronized可重入和可见性 <a class="header-anchor" href="#synchronized可重入和可见性" aria-label="Permalink to &quot;Synchronized可重入和可见性&quot;">​</a></h2><h3 id="synchronized-的可重入性实现" tabindex="-1">Synchronized 的可重入性实现 <a class="header-anchor" href="#synchronized-的可重入性实现" aria-label="Permalink to &quot;Synchronized 的可重入性实现&quot;">​</a></h3><p><strong>Synchronized</strong> 的可重入性是通过以下机制实现的：</p><ol><li><p><strong>锁记录（Lock Record）</strong>：当一个线程第一次获取某个对象的锁时，Java 会创建一个 <strong>锁记录</strong>（Lock Record）。<strong>锁记录</strong> 包含以下信息：</p><ul><li><strong>锁拥有者</strong>（Lock Owner）：指向当前持有锁的线程。</li><li><strong>进入计数器</strong>（Entry Count）：记录当前线程进入同步代码块或方法的次数。</li><li><strong>等待队列</strong>（Wait Queue）：存储等待该锁的线程。</li></ul></li><li><p><strong>CAS 操作</strong>：Java 使用 <strong>CAS</strong>（Compare And Swap）操作来获取和释放锁。<strong>CAS</strong> 操作是一种原子操作，它可以保证在一个线程修改变量值之前，没有其他线程对该变量进行修改。</p></li></ol><p><strong>当一个线程试图获取某个对象的锁时，会执行以下步骤：</strong></p><ol><li>读取对象的 <strong>锁标志</strong>。</li><li>如果 <strong>锁标志</strong> 为 0，则表示锁没有被任何线程持有，该线程可以直接获取锁，并更新 <strong>锁标志</strong> 为自己的线程 ID。</li><li>如果 <strong>锁标志</strong> 不为 0，则表示锁已经被其他线程持有，该线程需要执行以下操作： <ul><li>如果 <strong>锁拥有者</strong> 是当前线程，则将 <strong>进入计数器</strong> 加 1，表示该线程再次进入同步代码块或方法。</li><li>如果 <strong>锁拥有者</strong> 不是当前线程，则加入 <strong>等待队列</strong>，并阻塞等待锁被释放。</li></ul></li></ol><p><strong>当一个线程释放锁时，会执行以下步骤：</strong></p><ol><li>将 <strong>进入计数器</strong> 减 1。</li><li>如果 <strong>进入计数器</strong> 为 0，则表示该线程已经完全退出同步代码块或方法，可以释放锁。</li><li>如果 <strong>进入计数器</strong> 不为 0，则表示该线程还没有完全退出同步代码块或方法，不能释放锁。</li></ol><p>**由于 <code>进入计数器</code> 记录了当前线程进入同步代码块或方法的次数，因此即使一个线程多次获取同一个对象的锁，也能保证锁的正确性。 **</p><h3 id="synchronized-可见性原理" tabindex="-1">Synchronized 可见性原理 <a class="header-anchor" href="#synchronized-可见性原理" aria-label="Permalink to &quot;Synchronized 可见性原理&quot;">​</a></h3><p><strong>Synchronized</strong> 是 Java 中用于实现同步的重要机制，它可以作用于 <strong>方法</strong> 和 <strong>代码块</strong> 两种地方，用于解决多线程并发访问导致的安全问题。其可见性是通过 <strong>刷新操作</strong>（Refresh Operation）来实现的。</p><h4 id="刷新操作-refresh-operation" tabindex="-1">刷新操作（Refresh Operation） <a class="header-anchor" href="#刷新操作-refresh-operation" aria-label="Permalink to &quot;刷新操作（Refresh Operation）&quot;">​</a></h4><p><strong>刷新操作</strong>（Refresh Operation）是指将共享变量的值从工作内存刷新到主内存的操作。Java 会在以下情况下执行 <strong>刷新操作</strong>：</p><ul><li>线程执行完 <strong>synchronized</strong> 代码块或方法。</li><li>线程调用 <strong>wait()</strong> 方法或 <strong>notify()</strong> 方法。</li><li>线程发生 <strong>GC</strong>（垃圾回收）。</li></ul><p><strong>当一个线程对共享变量进行修改时，首先会将修改后的值写入到自己的工作内存中。</strong> 只有当其他线程需要访问该共享变量时，才会从主内存中读取最新值。</p><p><strong>例如，</strong> 考虑以下代码：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Counter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将 count 的值增加 1，并写入到工作内存中。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从工作内存中读取 count 的值。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在这个例子中，<code>increment()</code> 方法会对共享变量 <code>count</code> 进行修改。<code>getCount()</code> 方法会读取共享变量 <code>count</code> 的值。</p><p><strong>如果 <code>increment()</code> 方法和 <code>getCount()</code> 方法都是非同步的，则可能发生以下情况：</strong></p><ul><li>线程 A 调用 <code>increment()</code> 方法，将 <code>count</code> 的值增加 1。</li><li>线程 B 调用 <code>getCount()</code> 方法，读取 <code>count</code> 的值。</li></ul><p>由于 <strong>刷新操作</strong> 不会立即执行，因此线程 B 可能读取到旧的值 0，而不是新值 1。</p><p><strong>如果 <code>increment()</code> 方法是同步的，则就不会发生这个问题。</strong> 这是因为 <strong>Synchronized</strong> 会在执行完 <strong>synchronized</strong> 代码块后执行 <strong>刷新操作</strong>，因此线程 B 能够立即感知到 <code>count</code> 的值已经被修改。</p><h4 id="synchronized-可见性保证" tabindex="-1">Synchronized 可见性保证 <a class="header-anchor" href="#synchronized-可见性保证" aria-label="Permalink to &quot;Synchronized 可见性保证&quot;">​</a></h4><p><strong>Synchronized</strong> 可以保证以下两个可见性：</p><ul><li><strong>happens-before</strong> 关系：如果一个线程 A 在 <strong>synchronized</strong> 代码块中执行了对共享变量的写操作，那么另一个线程 B 在后续的 <strong>synchronized</strong> 代码块中读取该共享变量的值，则可以看到线程 A 写入的值。</li><li><strong>程序顺序可见性</strong>：如果一个线程在程序顺序中执行了对共享变量的写操作，那么另一个线程在后续的任何地方读取该共享变量的值，都能够看到线程 A 写入的值。</li></ul><p><strong>happens-before</strong> 关系是一种比较弱的可见性保证，它只保证了两个操作的发生顺序，但不能保证两个操作的原子性。**程序顺序可见性 ** 是一种比较强的可见性保证，它不仅保证了两个操作的发生顺序，还保证了两个操作的原子性。</p><p><strong>需要注意的是，</strong> Synchronized 的可见性只限于 <strong>同一个对象</strong> 的 <strong>synchronized</strong> 代码块或方法之间。如果需要跨越多个对象的可见性，则需要使用其他同步机制，例如 <strong>volatile</strong> 关键字或 <strong>happens-before</strong> 关系。</p>`,84)]))}const y=n(l,[["render",o]]);export{E as __pageData,y as default};
