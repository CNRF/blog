import{_ as t,c as i,o as e,a3 as s}from"./chunks/framework.DY6izP8J.js";const l="/blog/assets/%E7%BA%BF%E7%A8%8B%E8%BD%AC%E6%8D%A2%E7%8A%B6%E6%80%81%E5%9B%BE.BlhV-Xsn.png",r="/blog/assets/markword%E6%A8%A1%E5%9E%8B.DL0pksi7.png",n="/blog/assets/1752300047172.B5Fwnfcz.png",o="/blog/assets/1752308255154.ByXQHblD.png",d="/blog/assets/1752544706223.SMC5RaUl.png",q=JSON.parse('{"title":"面试","description":"","frontmatter":{"title":"面试","tags":[""],"categories":[""]},"headers":[],"relativePath":"interview/面试.md","filePath":"interview/面试.md","lastUpdated":1752547624000}'),h={name:"interview/面试.md"};function c(p,a,k,u,g,b){return e(),i("div",null,a[0]||(a[0]=[s(`<h2 id="java基础" tabindex="-1">Java基础 <a class="header-anchor" href="#java基础" aria-label="Permalink to &quot;Java基础&quot;">​</a></h2><h3 id="面向对象的三大特性" tabindex="-1">面向对象的三大特性 <a class="header-anchor" href="#面向对象的三大特性" aria-label="Permalink to &quot;面向对象的三大特性&quot;">​</a></h3><ol><li>封装：将数据和操作数据的方法封装在一起，隐藏内部实现细节。</li><li>继承：允许一个类继承另一个类的属性和方法，促进代码复用。</li><li>多态：允许不同类的对象以相同的方式调用方法，具体实现由对象的实际类型决定。</li></ol><h3 id="java的基本数据类型" tabindex="-1">Java的基本数据类型 <a class="header-anchor" href="#java的基本数据类型" aria-label="Permalink to &quot;Java的基本数据类型&quot;">​</a></h3><p>Java的基本数据类型包括：</p><ul><li>整数类型：<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code></li><li>浮点类型：<code>float</code>, <code>double</code></li><li>字符类型：<code>char</code></li><li>布尔类型：<code>boolean</code></li></ul><h3 id="java的基础类型和包装类型区别" tabindex="-1">Java的基础类型和包装类型区别 <a class="header-anchor" href="#java的基础类型和包装类型区别" aria-label="Permalink to &quot;Java的基础类型和包装类型区别&quot;">​</a></h3><ol><li>基本类型有默认值，而包装类型默认为null。</li><li>包装类型可以用于泛型和集合，而基本类型不能。</li><li>包装类型是对象，具有方法和属性，而基本类型是原始数据</li><li><code>基本数据类型的局部变量</code>存放在jvm的局部变量表中，而<code>包装类型的局部变量</code>存放在堆中。</li></ol><h3 id="java的包装类型的封箱和拆箱" tabindex="-1">Java的包装类型的封箱和拆箱 <a class="header-anchor" href="#java的包装类型的封箱和拆箱" aria-label="Permalink to &quot;Java的包装类型的封箱和拆箱&quot;">​</a></h3><ul><li>装箱：将基本类型⽤它们对应的引⽤类型包装起来,实际是调用了xxxValueOf方法； <ul><li>例如：<code>int a = 10; Integer b = Integer.valueOf(a);</code></li></ul></li><li>拆箱：将包装类型转换为基本数据类型,实际是调用了xxxValue方法； <ul><li>例如：<code>Integer b = Integer.valueOf(10); int a = b.intValue();</code></li></ul></li></ul><h3 id="java的包装类型的缓存机制" tabindex="-1">Java的包装类型的缓存机制 <a class="header-anchor" href="#java的包装类型的缓存机制" aria-label="Permalink to &quot;Java的包装类型的缓存机制&quot;">​</a></h3><ul><li><strong><code>Byte</code></strong>: 缓存范围是 <strong>-128 到 127</strong>。</li><li><strong><code>Short</code></strong>: 缓存范围是 <strong>-128 到 127</strong>。</li><li><strong><code>Integer</code></strong>: 缓存范围是 <strong>-128 到 127</strong>。</li><li><strong><code>Long</code></strong>: 缓存范围是 <strong>-128 到 127</strong>。</li><li><strong><code>Character</code></strong>: 缓存范围是 <strong>0 到 127</strong> (即 ASCII 字符范围)。</li><li><strong><code>Boolean</code></strong>: 缓存了 <code>TRUE</code> 和 <code>FALSE</code> 两个常量对象。</li></ul><p><strong><code>Float</code> 和 <code>Double</code> 没有缓存机制。</strong> 这是因为浮点数没有固定且精确的有限范围，并且浮点数的比较涉及精度问题，缓存会带来额外的复杂性且收益不大。</p><ul><li><strong>性能优化：</strong> 减少了频繁创建小整数、字符和布尔值对象的开销，尤其是在大量使用这些值的情况下。</li><li><strong>内存节省：</strong> 避免了为相同的小值重复创建对象，从而降低了内存占用。</li></ul><h4 id="缓存机制是如何工作的" tabindex="-1">缓存机制是如何工作的 <a class="header-anchor" href="#缓存机制是如何工作的" aria-label="Permalink to &quot;缓存机制是如何工作的&quot;">​</a></h4><p>当你在以上缓存范围内的值进行<strong>自动装箱</strong>（例如 <code>Integer i = 100;</code>）时，JVM 会执行以下步骤：</p><ol><li><strong>检查缓存：</strong> 它会首先检查内部缓存中是否已经存在一个表示该值的对象。</li><li><strong>返回引用：</strong> 如果存在，JVM 会直接返回该对象的引用，而不是创建一个新的 <code>Integer</code> 对象。</li><li><strong>创建新对象：</strong> 如果缓存中不存在该值，或者该值超出了缓存范围，JVM 才会创建新的对象。对于 <code>Integer</code>、<code>Byte</code> 等类型，这通常通过调用 <code>valueOf()</code> 方法来实现，而 <code>valueOf()</code> 方法内部就包含了缓存逻辑。</li></ol><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> WrapperCacheExample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Integer 缓存示例</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Integer a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自动装箱，100 在缓存范围内</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Integer b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Integer 100 == 100: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true，因为它们引用同一个缓存对象</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Integer c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自动装箱，200 超出缓存范围</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Integer d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Integer 200 == 200: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// false，因为它们是不同的对象</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Character 缓存示例</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Character ch1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自动装箱，&#39;a&#39; 的 ASCII 值在缓存范围内</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Character ch2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Character &#39;a&#39; == &#39;a&#39;: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ch1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ch2)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Character ch3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;€&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自动装箱，欧元符号的 Unicode 值通常超出 127</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Character ch4 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;€&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Character &#39;€&#39; == &#39;€&#39;: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ch3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ch4)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // Boolean 缓存示例</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Boolean bool1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自动装箱，true 缓存</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Boolean bool2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Boolean true == true: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (bool1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bool2)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h3 id="重载和重写的区别" tabindex="-1">重载和重写的区别 <a class="header-anchor" href="#重载和重写的区别" aria-label="Permalink to &quot;重载和重写的区别&quot;">​</a></h3><ol><li><strong>定义</strong>： <ul><li><strong>重载（Overloading）</strong>：同一个类中，方法名相同但参数列表不同（参数类型、数量或顺序不同）。</li><li><strong>重写（Overriding）</strong>：子类重新定义父类中的方法，方法名、返回类型和参数列表都必须相同。</li></ul></li><li><strong>目的</strong>： <ul><li><strong>重载</strong>：提供多种方式来调用同一方法，增强代码</li><li><strong>重写</strong>：实现多态性，允许子类提供特定的实现。</li></ul></li><li><strong>编译时和运行时</strong>： <ul><li><strong>重载</strong>：在编译时决定调用哪个方法（静态绑定）。</li><li><strong>重写</strong>：在运行时决定调用哪个方法（动态绑定）。</li></ul></li><li><strong>参数</strong>： <ul><li><strong>重载</strong>：参数列表必须不同（类型、数量或顺序）。</li><li><strong>重写</strong>：参数列表必须完全相同。</li></ul></li><li><strong>返回类型</strong>： <ul><li><strong>重载</strong>：可以有不同的返回类型。</li><li><strong>重写</strong>：返回类型必须相同或是父类返回类型的</li></ul></li></ol><h3 id="静态方法为什么不能被重写" tabindex="-1">静态方法为什么不能被重写 <a class="header-anchor" href="#静态方法为什么不能被重写" aria-label="Permalink to &quot;静态方法为什么不能被重写&quot;">​</a></h3><p>静态方法不能被重写的原因是因为静态方法属于类而不是实例。它们在编译时就已经确定了调用哪个方法， 而不是在运行时根据对象的实际类型来决定。因此，静态方法的调用是基于引用类型而不是对象类型。</p><h3 id="静态方法为什么不能调用非静态方法" tabindex="-1">静态方法为什么不能调用非静态方法 <a class="header-anchor" href="#静态方法为什么不能调用非静态方法" aria-label="Permalink to &quot;静态方法为什么不能调用非静态方法&quot;">​</a></h3><p>静态方法不能直接调用非静态方法，因为非静态方法依赖于实例对象的状态，而静态方法属于类本身，不依赖于任何实例对象。 在静态方法中没有 <code>this</code> 引用，因此无法访问非静态方法和属性。</p><h3 id="接口和抽象类的区别" tabindex="-1">接口和抽象类的区别 <a class="header-anchor" href="#接口和抽象类的区别" aria-label="Permalink to &quot;接口和抽象类的区别&quot;">​</a></h3><ol><li><strong>定义</strong>： <ul><li><strong>接口（Interface）</strong>：只包含方法的声明，没有方法的实现。可以包含常量。</li><li><strong>抽象类（Abstract Class）</strong>：可以包含方法的声明和部分实现，也可以包含常量和实例变量。</li></ul></li><li><strong>继承</strong>： <ul><li><strong>接口</strong>：一个类可以实现多个接口（多重继承）。</li><li><strong>抽象类</strong>：一个类只能继承一个抽象类（单继承）。</li></ul></li><li><strong>方法实现</strong>： <ul><li><strong>接口</strong>：所有方法默认是 <code>public</code> 和 <code>abstract</code>，从 Java 8 开始可以有默认方法（<code>default</code>）和静态方法。</li><li><strong>抽象类</strong>：可以有 <code>public</code>、<code>protected</code> 和 <code>private</code> 方法，可以有具体方法的实现。</li></ul></li><li><strong>构造函数</strong>： <ul><li><strong>接口</strong>：没有构造函数，因为接口不能被实例化。</li><li><strong>抽象类</strong>：可以有构造函数，可以被实例化为子类的对象。</li></ul></li><li><strong>字段</strong>： <ul><li><strong>接口</strong>：只能包含 <code>public static final</code> 常量。</li><li><strong>抽象类</strong>：可以包含实例变量，可以有不同的访问修饰符。</li></ul></li><li><strong>使用场景</strong>： <ul><li><strong>接口</strong>：适用于定义一组行为或功能，强调的是能力和契约。</li><li><strong>抽象类</strong>：适用于定义一组相关的类，强调的是共享的状态和行为。</li></ul></li></ol><h3 id="深拷贝和浅拷贝的区别" tabindex="-1">深拷贝和浅拷贝的区别 <a class="header-anchor" href="#深拷贝和浅拷贝的区别" aria-label="Permalink to &quot;深拷贝和浅拷贝的区别&quot;">​</a></h3><ol><li><strong>定义</strong>： <ul><li><strong>浅拷贝（Shallow Copy）</strong>：创建一个新对象，但只复制对象的引用，对于引用类型的属性，仍然指向原对象的内存地址。</li><li><strong>深拷贝（Deep Copy）</strong>：创建一个新对象，并递归地复制所有属性，包括引用类型的属性，确保新对象和原对象完全独立。</li></ul></li><li><strong>内存分配</strong>： <ul><li><strong>浅拷贝</strong>：新对象和原对象共享引用类型属性的内存地址。</li><li><strong>深拷贝</strong>：新对象和原对象的所有属性都在不同的内存地址上，完全独立。</li></ul></li><li><strong>影响</strong>： <ul><li><strong>浅拷贝</strong>：修改新对象的引用类型属性会影响原对象，因为它们指向同一内存地址。</li><li><strong>深拷贝</strong>：修改新对象的引用类型属性不会影响原对象，因为它们有各自独立的内存地址。</li></ul></li><li><strong>实现方式</strong>： <ul><li><strong>浅拷贝</strong>：通常使用 <code>clone()</code> 方法或构造函数来实现。</li><li><strong>深拷贝</strong>：可以通过序列化和反序化、手动复制每个属性或使用第三方库（如 Apache Commons Lang 的 <code>SerializationUtils</code> ）来实现。</li></ul></li></ol><h3 id="object类的常用方法" tabindex="-1">Object类的常用方法 <a class="header-anchor" href="#object类的常用方法" aria-label="Permalink to &quot;Object类的常用方法&quot;">​</a></h3><ul><li><code>equals(Object obj)</code>：比较两个对象是否相等。</li><li><code>hashCode()</code>：返回对象的哈希码，用于哈希表等数据结构。</li><li><code>toString()</code>：返回对象的字符串表示形式。</li><li><code>getClass()</code>：返回对象的运行时类。</li><li><code>clone()</code>：创建并返回对象的一个副本（浅拷贝）。</li><li><code>finalize()</code>：在垃圾回收前调用，用于清理资源（不推荐使用）。</li><li><code>notify()</code>：唤醒在此对象监视器上等待的单个线程。</li><li><code>notifyAll()</code>：唤醒在此对象监视器上等待的所有线程。</li><li><code>wait()</code>：使当前线程等待，直到其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法。</li><li><code>wait(long timeout)</code>：使当前线程等待，直到其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法，或等待超时。</li><li><code>wait(long timeout, int nanos)</code>：使当前线程等待，直到其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法，或等待超时和纳秒。</li><li><code>getClassLoader()</code>：返回加载此类的类加载器。</li><li><code>getClass()</code>: 返回对象的运行时类。</li></ul><h3 id="为什么重写equals方法时也要重写hashcode方法" tabindex="-1">为什么重写<code>equals</code>方法时也要重写<code>hashCode</code>方法 <a class="header-anchor" href="#为什么重写equals方法时也要重写hashcode方法" aria-label="Permalink to &quot;为什么重写\`equals\`方法时也要重写\`hashCode\`方法&quot;">​</a></h3><p>重写 <code>equals</code> 方法时也要重写 <code>hashCode</code> 方法的原因是：</p><ol><li><strong>一致性</strong>：如果两个对象通过 <code>equals</code> 方法被认为是相等的，那么它们的 <code>hashCode</code> 方法也必须返回相同的哈希码。</li><li><strong>哈希表的正确性</strong>：在使用哈希表（如 <code>HashMap</code>）等数据结构时，哈希码用于定位对象的位置。如果两个相等的对象具有不同的哈希码，可能导致哈希表无法正确找到或存储对象。</li><li><strong>性能优化</strong>：哈希码可以加速对象的查找和比较操作。如果 <code>equals</code> 方法被重写而 <code>hashCode</code> 方法没有被重写，可能会导致哈希表的性能下降，因为相等的对象可能会被分配到不同的桶中。</li></ol><h3 id="equal和-的区别-及比较的类型" tabindex="-1">equal和<code>==</code>的区别，及比较的类型 <a class="header-anchor" href="#equal和-的区别-及比较的类型" aria-label="Permalink to &quot;equal和\`==\`的区别，及比较的类型&quot;">​</a></h3><ol><li>基本类型比较 ==: 当用于基本数据类型（如int, char, boolean等）时，==比较的是它们的值是否相等。</li><li>引用类型比较 <ul><li>==: 当用于引用类型（如对象、数组）时，==比较的是两个对象的引用是否指向堆内存中的同一个地址，也就是说，它们是否是同一个对象的实例。即使两个对象的内容完全相同，但如果它们是在内存中的不同位置创建的，==也会判断为不相等。</li><li>equals(): equals()方法默认的行为同样是比较对象的引用是否相同，但是很多类（如String, Integer等）都重写了equals() 方法，使其比较的是对象的内容是否相等，而不是引用是否相同。这意味着，对于这些类的实例，如果你使用equals() 来比较，它会检查两个对象的内容（比如字符串的字符序列，Integer的值等）是否相等。</li></ul></li></ol><h3 id="string-stringbuffer-stringbuilder的区别" tabindex="-1">String, StringBuffer, StringBuilder的区别 <a class="header-anchor" href="#string-stringbuffer-stringbuilder的区别" aria-label="Permalink to &quot;String, StringBuffer, StringBuilder的区别&quot;">​</a></h3><table><thead><tr><th>特性</th><th><code>String</code></th><th><code>StringBuffer</code></th><th><code>StringBuilder</code></th></tr></thead><tbody><tr><td>是否可变</td><td>❌ 不可变（<strong>final</strong>）</td><td>✅ 可变</td><td>✅ 可变</td></tr><tr><td>线程安全</td><td>✅ 线程安全（<strong>加锁</strong>）</td><td>✅ 线程安全（方法加 <code>synchronized</code>）</td><td>❌ 非线程安全</td></tr><tr><td>性能（单线程）</td><td>最差（每次操作新建对象）</td><td>较差（加锁带来开销）</td><td>最快（无锁、原地操作）</td></tr><tr><td>使用场景</td><td>小量字符串、不频繁修改</td><td>多线程环境中字符串频繁修改</td><td>单线程环境中字符串频繁修改</td></tr></tbody></table><h3 id="string为什么不可变" tabindex="-1">String为什么不可变 <a class="header-anchor" href="#string为什么不可变" aria-label="Permalink to &quot;String为什么不可变&quot;">​</a></h3><p>因为String 被final修饰，不能被继承， 所以String类的实例一旦创建就不能被修改。不可变字符串的设计有以下几个好处：</p><ol><li>安全性：防止被串改，导致攻击</li><li>线程安全</li><li>性能优化：字符串常量池，避免重复创建相同内容的字符串对象</li><li>内存优化：不可变字符串可以被共享，减少内存占用</li><li>作为HashMap的key时，保证hash值不变</li></ol><h3 id="string-s1-new-string-abc-创建了几个字符串对象" tabindex="-1">String s1=new String(&quot;abc&quot;)创建了几个字符串对象 <a class="header-anchor" href="#string-s1-new-string-abc-创建了几个字符串对象" aria-label="Permalink to &quot;String s1=new String(&quot;abc&quot;)创建了几个字符串对象&quot;">​</a></h3><blockquote><p><strong>最多创建了 2 个对象</strong>，分别是：</p><ol><li>字符串常量 <code>&quot;abc&quot;</code>（在字符串常量池中）</li><li>通过 <code>new</code> 创建的堆内存中的一个 <code>String</code> 对象（内容是 <code>&quot;abc&quot;</code> 的副本）</li></ol></blockquote><table><thead><tr><th>表达式</th><th>常量池中对象</th><th>堆中对象</th><th>说明</th></tr></thead><tbody><tr><td><code>String s = &quot;abc&quot;;</code></td><td>1</td><td>0</td><td>只创建常量池对象</td></tr><tr><td><code>String s = new String(&quot;abc&quot;);</code></td><td>1（如果未存在）</td><td>1</td><td>最多创建 2 个对象</td></tr></tbody></table><h3 id="什么是反射-反射的作用" tabindex="-1">什么是反射，反射的作用 <a class="header-anchor" href="#什么是反射-反射的作用" aria-label="Permalink to &quot;什么是反射，反射的作用&quot;">​</a></h3><p>反射是指在运行时动态地获取类的信息（如类名、方法、字段等） 以及操作类的实例（如调用方法、修改字段值等）的能力。Java中的反射机制允许程序在运行时检查和操作类的结构。</p><p>反射的作用包括：</p><ol><li><strong>动态加载类</strong>：可以在运行时加载类，而不需要在编译时确定类的类型。</li><li><strong>获取类的信息</strong>：可以获取类的名称、方法、字段、构造函数等信息。</li><li><strong>动态调用方法</strong>：可以在运行时调用类的方法，而不需要在编译时确定方法的名称和参数。</li><li><strong>修改字段值</strong>：可以在运行时修改类的字段值，即使这些字段是私有的。</li><li><strong>实现通用框架</strong>：反射可以用于实现通用的框架和库，如依赖注入、ORM（对象关系映射）等。</li></ol><h3 id="什么是spi-以及spi的作用" tabindex="-1">什么是SPI，以及SPI的作用 <a class="header-anchor" href="#什么是spi-以及spi的作用" aria-label="Permalink to &quot;什么是SPI，以及SPI的作用&quot;">​</a></h3><p>SPI（Service Provider Interface）是一种服务提供者接口的机制，用于在Java中实现模块化和插件化。它允许开发者定义一组接口，并让其他模块或库提供这些接口的具体实现。 SPI的作用包括：</p><ol><li><strong>模块化设计</strong>：通过SPI，可以将应用程序分成多个模块，每个模块可以独立开发和测试。</li><li><strong>插件化架构</strong>：允许第三方开发者提供插件，实现特定功能，而不需要修改主应用程序代码。</li><li><strong>解耦合</strong>：SPI使得应用程序的核心逻辑与具体实现解耦，便于替换和扩展。</li><li><strong>动态加载</strong>：可以在运行时动态加载和使用服务提供者的实现，而不需要在编译时确定具体的实现类。</li><li><strong>增强可维护性</strong>：通过SPI，可以轻松添加、删除或替换服务提供者的实现，而不影响主应用程序的代码。</li></ol><h3 id="序列化的作用" tabindex="-1">序列化的作用 <a class="header-anchor" href="#序列化的作用" aria-label="Permalink to &quot;序列化的作用&quot;">​</a></h3><table><thead><tr><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>✅ 网络传输</td><td>对象在网络上传输前必须变成字节流，比如 RPC、RMI</td></tr><tr><td>✅ 本地持久化</td><td>将对象写入文件/数据库，如缓存或快照</td></tr><tr><td>✅ 分布式系统通信</td><td>多个服务之间传输数据对象时使用序列化</td></tr><tr><td>✅ 跨 JVM 使用</td><td>不同 JVM 间共享数据或调用服务时使用</td></tr></tbody></table><h3 id="为什么不推荐jdk自带的序列化" tabindex="-1">为什么不推荐JDK自带的序列化 <a class="header-anchor" href="#为什么不推荐jdk自带的序列化" aria-label="Permalink to &quot;为什么不推荐JDK自带的序列化&quot;">​</a></h3><table><thead><tr><th>问题点</th><th>说明</th></tr></thead><tbody><tr><td>❌ 体积大</td><td>带有很多类结构信息（类名、字段、继承结构等），<strong>数据臃肿</strong></td></tr><tr><td>❌ 性能差</td><td>序列化/反序列化速度慢，<strong>不适合高并发场景</strong></td></tr><tr><td>❌ 不跨语言</td><td>只能在 Java 内部使用，<strong>无法与其他语言交互</strong></td></tr><tr><td>❌ 可读性差</td><td>序列化后的数据是二进制，不可读，不便调试</td></tr><tr><td>❌ 不灵活</td><td>对象结构一旦改变（加字段、删字段），<strong>兼容性差</strong>，容易出错</td></tr><tr><td>❌ 安全隐患</td><td>反序列化可被攻击（如反序列化漏洞、反射攻击）</td></tr></tbody></table><h2 id="java的集合" tabindex="-1">Java的集合 <a class="header-anchor" href="#java的集合" aria-label="Permalink to &quot;Java的集合&quot;">​</a></h2><h3 id="java集合的常见类型" tabindex="-1">Java集合的常见类型 <a class="header-anchor" href="#java集合的常见类型" aria-label="Permalink to &quot;Java集合的常见类型&quot;">​</a></h3><ul><li>List： <ul><li>ArrayList: 动态数组实现，支持随机访问，适合频繁读取。</li><li>LinkedList: 双向链表实现，支持高效的插入和删除操作，适合频繁修改。</li><li>Vector: 线程安全的动态数组实现，性能较低，已不推荐使用。</li><li>Stack: 继承自 Vector，表示后进先出（LIFO）的栈结构，已不推荐使用。</li></ul></li><li>Set: <ul><li>HashSet: 基于哈希表实现，元素唯一，无序。</li><li>LinkedHashSet: 基于哈希表和链表实现，元素唯一，保持插入顺序。</li><li>TreeSet: 基于红黑树实现，元素唯一，按自然顺序或指定比较器排序。</li></ul></li><li>Map: <ul><li>HashMap: 基于哈希表实现，键值对存储，键唯一，无序。key可以为null</li><li>LinkedHashMap: 基于哈希表和链表实现，键值对存储，键唯一，保持插入顺序。</li><li>TreeMap： 基于红黑树实现，键值对存储，键唯一，按自然顺序或指定比较器排序。</li><li>Hashtable： 基于哈希表实现，线程安全，键值对存储，键唯一，无序。key不可以为null</li><li>ConcurrentHashMap： 基于分段锁的哈希表实现，线程安全，键值对存储，键唯一，无序。key不可以为null</li></ul></li><li>Queue: <ul><li>PriorityQueue： 基于优先级堆实现，元素按优先级排序，允许重复元素。</li><li>LinkedList（也可以作为队列使用）： 双向链表实现，支持队列操作（FIFO）。</li><li>ArrayDeque： 基于动态数组实现的双端队列，支持队列和栈操作。</li></ul></li></ul><h3 id="arraylist能否存放null" tabindex="-1">ArrayList能否存放null <a class="header-anchor" href="#arraylist能否存放null" aria-label="Permalink to &quot;ArrayList能否存放null&quot;">​</a></h3><p>是的，<code>ArrayList</code> 可以存放 <code>null</code> 值。<code>ArrayList</code> 是一个动态数组实现的集合类，它允许存储 <code>null</code> 元素。你可以在 <code>ArrayList</code> 中添加多个 <code>null</code> 值，或者将某个索引位置的元素设置为 <code>null</code>。</p><h3 id="arraylist和linkedlist的区别" tabindex="-1">ArrayList和LinkedList的区别 <a class="header-anchor" href="#arraylist和linkedlist的区别" aria-label="Permalink to &quot;ArrayList和LinkedList的区别&quot;">​</a></h3><table><thead><tr><th>特性</th><th>ArrayList</th><th>LinkedList</th></tr></thead><tbody><tr><td>存储结构</td><td>动态数组（基于数组实现）</td><td>双向链表（基于节点实现）</td></tr><tr><td>随机访问性能</td><td>快速（O(1)）</td><td>慢（O(n)），需要遍历链表</td></tr><tr><td>插入和删除性能</td><td>慢（O(n)），需要移动元素</td><td>快（O(1)），只需修改指针</td></tr><tr><td>内存使用</td><td>内存连续，空间利用率高</td><td>内存不连续，每个节点有额外的指针开销</td></tr><tr><td>线程安全</td><td>非线程安全（需要手动同步）</td><td>非线程安全（需要手动同步）</td></tr><tr><td>适用场景</td><td>频繁读取，少量插入和删除操作</td><td>频繁插入和删除操作，较少读取操作</td></tr><tr><td>是否支持null</td><td>可以存放 null 值</td><td>可以存放 null 值</td></tr></tbody></table><h3 id="arraylist的扩容机制" tabindex="-1">ArrayList的扩容机制 <a class="header-anchor" href="#arraylist的扩容机制" aria-label="Permalink to &quot;ArrayList的扩容机制&quot;">​</a></h3><p><code>ArrayList</code> 的扩容机制是当添加元素时，如果当前数组的容量不足以容纳新元素，<code>ArrayList</code> 会自动扩容。具体过程如下：</p><ol><li><strong>检查容量</strong>：当添加新元素时，首先检查当前数组的长度是否小于 <code>size</code>（当前元素数量）。</li><li><strong>扩容</strong>：如果容量不足，<code>ArrayList</code> 会创建一个新的数组，通常是当前容量的 1.5 倍</li><li><strong>复制元素</strong>：将原数组中的元素复制到新数组中。</li><li><strong>更新引用</strong>：将 <code>ArrayList</code> 的内部数组引用指向新数组。</li><li><strong>添加新元素</strong>：将新元素添加到新数组的末尾。</li><li><strong>更新大小</strong>：更新 <code>size</code> 属性，表示当前元素数量。</li><li><strong>释放旧数组</strong>：原数组会被垃圾回收器回收（如果没有其他引用指向它）。</li></ol><h3 id="hashmap-hashtable-concurrenthashmap的区别" tabindex="-1">HashMap,Hashtable,ConcurrentHashMap的区别 <a class="header-anchor" href="#hashmap-hashtable-concurrenthashmap的区别" aria-label="Permalink to &quot;HashMap,Hashtable,ConcurrentHashMap的区别&quot;">​</a></h3><table><thead><tr><th>特性</th><th>HashMap</th><th>Hashtable</th><th>ConcurrentHashMap</th></tr></thead><tbody><tr><td>是否线程安全</td><td>❌ 非线程安全</td><td>✅ 线程安全（使用同步方法）</td><td>✅ 线程安全（使用分段锁）</td></tr><tr><td>是否允许 null 键或值</td><td>✅ 允许 null 键和 null 值</td><td>❌ 不允许 null 键和 null 值</td><td>❌ 不允许 null 键和 null 值</td></tr><tr><td>性能</td><td>较快（无锁）</td><td>较慢（锁竞争）</td><td>较快（分段锁，减少锁竞争）</td></tr><tr><td>初始容量和负载因子</td><td>可设置初始容量和负载因子（默认 16 和 0.75）</td><td>可设置初始容量和负载因子（默认 11 和 0.75）</td><td>可设置初始容量和负载因子（默认 16 和 0.75）</td></tr><tr><td>遍历方式</td><td>使用迭代器遍历，可能抛出 <code>ConcurrentModificationException</code></td><td>使用迭代器遍历，可能抛出 <code>ConcurrentModificationException</code></td><td>使用迭代器遍历，线程安全，不抛出异常</td></tr><tr><td>键值对存储方式</td><td>基于哈希表实现，允许重复键（覆盖旧值）</td><td>基于哈希表实现，允许重复键（覆盖旧值）</td><td>基于分段哈希表实现，允许重复键（覆盖旧值）</td></tr><tr><td>适用场景</td><td>单线程或少量线程环境，快速查找和插入</td><td>多线程环境，线程安全但性能较低</td><td>多线程环境，性能较高，适合高并发场景</td></tr></tbody></table><h3 id="hashmap的底层实现-jdk1-7和jdk1-8" tabindex="-1">HashMap的底层实现（JDK1.7和JDK1.8） <a class="header-anchor" href="#hashmap的底层实现-jdk1-7和jdk1-8" aria-label="Permalink to &quot;HashMap的底层实现（JDK1.7和JDK1.8）&quot;">​</a></h3><table><thead><tr><th>特性</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>数据结构</td><td>数组 + 链表（链地址法）</td><td>数组 + 链表 + 红黑树（链表过长转红黑树）</td></tr><tr><td>头插 or 尾插</td><td>头插法（新节点放在前面）</td><td>尾插法（保持原顺序，利于树化）</td></tr><tr><td>哈希冲突处理方式</td><td>链地址法（单向链表）</td><td>链地址 + 树化优化</td></tr><tr><td>线程安全</td><td>❌ 不安全</td><td>❌ 不安全</td></tr><tr><td>容量默认</td><td>16</td><td>16</td></tr><tr><td>加载因子</td><td>0.75</td><td>0.75</td></tr><tr><td>触发树化条件</td><td>无</td><td>链表长度 &gt; 8 且数组长度 ≥ 64</td></tr></tbody></table><h3 id="hashmap的key可以为null吗-为什么currenthashmap的key不可以为null" tabindex="-1">HashMap的key可以为null吗，为什么CurrentHashMap的key不可以为null <a class="header-anchor" href="#hashmap的key可以为null吗-为什么currenthashmap的key不可以为null" aria-label="Permalink to &quot;HashMap的key可以为null吗，为什么CurrentHashMap的key不可以为null&quot;">​</a></h3><p><code>HashMap</code> 的 key 可以为 <code>null</code>，而 <code>ConcurrentHashMap</code> 的 key 不可以为 <code>null</code>。</p><ol><li><strong>HashMap 的 key 可以为 null</strong> 在 Java 的 <code>HashMap</code> 中，允许将 <code>null</code> 作为键（key）。这是因为 <code>HashMap</code> 的内部实现明确支持 <code>null</code> 键的存储和处理： <ul><li>当插入 <code>null</code> 键时，<code>HashMap</code> 会将其存储在哈希表的索引 0 处（即 <code>table[0]</code>）。</li><li><code>HashMap</code> 的 <code>put</code> 方法在处理 <code>null</code> 键时有专门的逻辑，确保 <code>null</code> 键能够被正确存储和检索。</li><li>由于 <code>HashMap</code> 是非线程安全的，它的设计更注重灵活性和简单性，因此允许 <code>null</code> 键和值以便于更广泛的使用场景。</li></ul></li><li><strong>ConcurrentHashMap 的 key 不可以为 null</strong><code>ConcurrentHashMap</code> 是线程安全的哈希表实现，设计上不允许 <code>null</code> 键（也不允许 <code>null</code> 值）。原因如下： <ul><li><strong>线程安全性和一致性</strong>：<code>ConcurrentHashMap</code> 为了保证线程安全，采用了分段锁（在 Java 8 及以上是 CAS 和 <code>synchronized</code> 机制）来管理并发访问。如果允许 <code>null</code> 键，会增加复杂性，因为 <code>null</code> 键需要特殊的处理逻辑，可能导致并发场景下出现不一致或难以调试的问题。</li><li><strong>语义清晰性</strong>：<code>ConcurrentHashMap</code> 的设计目标是高并发环境下的高效性和可靠性。<code>null</code> 键可能会引发歧义（例如， <code>get(key)</code> 返回 <code>null</code> 可能是键不存在，也可能是键存在但值是 <code>null</code>），这在并发环境中会增加开发者的心智负担。</li><li><strong>内部实现限制</strong>：<code>ConcurrentHashMap</code> 的哈希计算和分段机制假设键是非空的。允许 <code>null</code> 键需要额外的检查和特殊处理，这会降低性能并增加代码复杂性。</li></ul></li></ol><h3 id="hashmap的put方法的过程" tabindex="-1">HashMap的put方法的过程 <a class="header-anchor" href="#hashmap的put方法的过程" aria-label="Permalink to &quot;HashMap的put方法的过程&quot;">​</a></h3><ol><li><p><strong>处理空键（null key）</strong>：</p><ul><li>如果传入的键是 <code>null</code>，<code>HashMap</code> 会特殊处理，将键值对存储在哈希表的索引 0 处（<code>table[0]</code>）。</li><li>否则，调用键的 <code>hashCode()</code> 方法，并通过内部的 <code>hash()</code> 方法对哈希值进行扰动（优化哈希分布，减少冲突）。</li></ul></li><li><p><strong>计算存储位置</strong>：</p><ul><li>使用计算得到的哈希值，通过 <code>(n - 1) &amp; hash</code> 确定键值对在哈希表数组（<code>table</code>）中的索引位置，其中 <code>n</code> 是数组长度。</li><li>这一步确保哈希值均匀分布到数组的各个桶（bucket）中。</li></ul></li><li><p><strong>检查哈希表是否需要初始化或扩容</strong>：</p><ul><li>如果哈希表数组（<code>table</code>）为 <code>null</code> 或为空，调用 <code>resize()</code> 方法初始化数组（默认初始容量为 16）。</li><li>如果当前键值对的插入会导致 <code>HashMap</code> 的元素数量超过阈值（<code>threshold = capacity * loadFactor</code>），则调用 <code>resize()</code> 方法扩容（通常容量翻倍）。</li></ul></li><li><p><strong>处理桶中的冲突</strong>：</p><ul><li>根据计算得到的索引，找到对应的桶（<code>table[i]</code>）。桶中可能有以下情况： <ul><li><strong>桶为空</strong>：直接创建一个新节点（<code>Node</code>），将键值对插入该桶。</li><li><strong>桶不为空</strong>： <ul><li>如果桶中是单个节点（非链表或红黑树），比较键是否相等（通过 <code>equals</code> 方法）： <ul><li>如果键相等，更新该节点的值（覆盖旧值）。</li><li>如果键不相等，创建一个新节点，追加到链表尾部。</li></ul></li><li>如果桶中是链表（多于一个节点），遍历链表： <ul><li>如果找到相同的键，更新值。</li><li>如果没有找到，追加新节点到链表尾部。</li></ul></li><li>如果桶中是红黑树（Java 8 引入，当链表长度超过 8 且数组容量足够时，链表转为红黑树）： <ul><li>调用红黑树的插入逻辑（<code>putTreeVal</code>）插入或更新键值对。</li></ul></li></ul></li></ul></li><li>如果链表长度达到 8 且数组容量大于等于 64，调用 <code>treeifyBin</code> 将链表转换为红黑树。</li></ul></li><li><p><strong>更新 size 和 modCount</strong>：</p><ul><li>插入新键值对后，<code>HashMap</code> 的 <code>size</code>（元素数量）加 1。</li><li><code>modCount</code>（修改计数器）加 1，用于检测并发修改（在迭代器中使用）。</li><li>如果 <code>size</code> 超过阈值，触发 <code>resize()</code> 扩容。</li></ul></li><li><p><strong>返回旧值</strong>：</p><ul><li>如果键已存在，返回旧值（<code>oldValue</code>）；否则返回 <code>null</code>。</li></ul></li></ol><h2 id="java并发" tabindex="-1">Java并发 <a class="header-anchor" href="#java并发" aria-label="Permalink to &quot;Java并发&quot;">​</a></h2><h3 id="线程和进程的区别" tabindex="-1">线程和进程的区别 <a class="header-anchor" href="#线程和进程的区别" aria-label="Permalink to &quot;线程和进程的区别&quot;">​</a></h3><p>进程：运行一个 Java 程序（java MyApp）会启动一个 JVM 进程，包含独立的堆和栈。 线程：在 Java 中，通过 Thread 类或 Runnable 接口创建线程，多个线程共享同一 JVM 进程的堆内存。</p><h3 id="并发和并行的区别" tabindex="-1">并发和并行的区别 <a class="header-anchor" href="#并发和并行的区别" aria-label="Permalink to &quot;并发和并行的区别&quot;">​</a></h3><p>并发：指在同一时间段内，多个任务交替执行，看起来像是“同时”进行，但实际上可能是在单个处理器上通过时间片轮转（time-slicing）实现的。 并行：指多个任务在同一时刻真正同时执行，通常依赖多核处理器或分布式系统，每个任务在独立的处理器或核心上运行。</p><h3 id="同步和异步的区别" tabindex="-1">同步和异步的区别 <a class="header-anchor" href="#同步和异步的区别" aria-label="Permalink to &quot;同步和异步的区别&quot;">​</a></h3><p>同步：任务按顺序执行，调用方必须等待当前任务完成才能继续执行后续操作。 异步：任务发起后，调用方无需等待任务完成，可以立即执行后续操作，任务结果通常通过回调、事件或轮询获取。</p><h3 id="java的线程创建方式" tabindex="-1">Java的线程创建方式 <a class="header-anchor" href="#java的线程创建方式" aria-label="Permalink to &quot;Java的线程创建方式&quot;">​</a></h3><ol><li><strong>继承 Thread 类</strong>：创建一个新的类继承自 <code>Thread</code>，重写 <code>run()</code> 方法，然后创建该类的实例并调用 <code>start()</code> 方法。<div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyThread</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Thread is running&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MyThread thread </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><strong>实现 Runnable 接口</strong>：创建一个实现 <code>Runnable</code> 接口的类，重写 <code>run()</code> 方法，然后将该类的实例传递给 <code>Thread</code> 的构造函数。<div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyRunnable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Thread is running&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Thread thread </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyRunnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><strong>使用 Lambda 表达式</strong>（Java 8 及以上）：如果 <code>run()</code> 方法没有参数，可以使用 Lambda 表达式简化代码。<div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Thread thread </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Thread is running&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li><li><strong>使用线程池</strong>：通过 <code>ExecutorService</code> 创建线程池，提交任务执行。</li></ol><div class="tip custom-block"><p class="custom-block-title">提示</p><p>本质上，最终启动线程的都是new Thread().start()方法，只是通过不同的方式传入了run方法。</p></div><h3 id="callable和runnable的区别" tabindex="-1">Callable和Runnable的区别 <a class="header-anchor" href="#callable和runnable的区别" aria-label="Permalink to &quot;Callable和Runnable的区别&quot;">​</a></h3><table><thead><tr><th>特性</th><th><code>Runnable</code></th><th><code>Callable</code></th></tr></thead><tbody><tr><td>返回值</td><td>无返回值（<code>void</code>）</td><td>有返回值（可以指定类型）</td></tr><tr><td>抛出异常</td><td>不能抛出检查异常（<code>checked exception</code>）</td><td>可以抛出检查异常（<code>checked exception</code>）</td></tr><tr><td>线程执行方式</td><td>通过 <code>Thread</code> 类或线程池执行</td><td>通过 <code>ExecutorService</code> 执行，支持异步处理</td></tr><tr><td>使用场景</td><td>适用于不需要返回结果的任务（如事件处理、日志记录等）</td><td>适用于需要返回结果或可能抛出异常的任务（如计算、IO操作等）</td></tr></tbody></table><h3 id="线程的状态转换" tabindex="-1">线程的状态转换 <a class="header-anchor" href="#线程的状态转换" aria-label="Permalink to &quot;线程的状态转换&quot;">​</a></h3><p><img src="`+l+'" alt=""></p><table><thead><tr><th style="text-align:center;">线程状态</th><th style="text-align:center;">导致状态发生条件</th></tr></thead><tbody><tr><td style="text-align:center;">NEW(新建)</td><td style="text-align:center;">线程刚被创建，但是并未启动。还没调用start方法。</td></tr><tr><td style="text-align:center;">Runnable(可运行)</td><td style="text-align:center;">线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于<br>操作系统处理器</td></tr><tr><td style="text-align:center;">Blocked(锁阻塞)</td><td style="text-align:center;">当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状<br>态；当该线程持有锁时，该线程将变成Runnable状态。</td></tr><tr><td style="text-align:center;">Waiting(无限等待)</td><td style="text-align:center;">一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个<br>状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒</td></tr><tr><td style="text-align:center;">TimedWaiting(计时等待)</td><td style="text-align:center;">同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。<br>这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep ,<br>Object.wait。</td></tr><tr><td style="text-align:center;">Teminated(被终止)</td><td style="text-align:center;">因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td></tr></tbody></table><h3 id="thread-sleep-和object-wait-的区别" tabindex="-1">Thread#sleep()和Object#wait()的区别 <a class="header-anchor" href="#thread-sleep-和object-wait-的区别" aria-label="Permalink to &quot;Thread#sleep()和Object#wait()的区别&quot;">​</a></h3><table><thead><tr><th>特性</th><th><code>Thread.sleep()</code></th><th><code>Object.wait()</code></th></tr></thead><tbody><tr><td>所属类</td><td><code>Thread</code> 类（静态方法）</td><td><code>Object</code> 类（实例方法）</td></tr><tr><td>是否释放锁</td><td>❌ <strong>不释放锁</strong>，仍然持有 <code>synchronized</code> 锁</td><td>✅ <strong>释放锁</strong>，进入等待队列</td></tr><tr><td>是否必须持有锁</td><td>❌ 不需要在同步块中调用</td><td>✅ <strong>必须</strong>在 <code>synchronized</code> 块中使用，否则抛异常</td></tr><tr><td>唤醒方式</td><td>时间到自动唤醒或被中断</td><td><code>notify()</code> / <code>notifyAll()</code> / 时间到自动唤醒</td></tr><tr><td>抛出异常</td><td><code>InterruptedException</code></td><td><code>InterruptedException</code>、<code>IllegalMonitorStateException</code></td></tr><tr><td>目的</td><td>暂停线程一段时间</td><td>等待某个条件或状态发生改变</td></tr><tr><td>使用场景</td><td>延迟执行、定时器、重试间隔</td><td>线程协作，如生产者-消费者模型</td></tr></tbody></table><h3 id="直接调用run方法和start方法的区别" tabindex="-1">直接调用run方法和start方法的区别 <a class="header-anchor" href="#直接调用run方法和start方法的区别" aria-label="Permalink to &quot;直接调用run方法和start方法的区别&quot;">​</a></h3><p>run() 是线程类的普通方法调用，不会启动新线程，代码在当前线程中顺序执行； 而 start() 是 Thread 类的方法，会真正启动一个新线程，由 JVM 调用 run() 方法执行任务，实现多线程并发。</p><h3 id="volatile关键字" tabindex="-1">volatile关键字 <a class="header-anchor" href="#volatile关键字" aria-label="Permalink to &quot;volatile关键字&quot;">​</a></h3><p>volatile 修饰的变量，每次读写都直接从主内存中操作，保证可见性，但不保证原子性。 在jvm中是通过禁止指令重排序和缓存来实现的。 在底层会在读写操作前后加上内存屏障（Memory Barrier），确保对 volatile 变量的读写操作不会被重排序。</p><h3 id="乐观锁和悲观锁的区别" tabindex="-1">乐观锁和悲观锁的区别 <a class="header-anchor" href="#乐观锁和悲观锁的区别" aria-label="Permalink to &quot;乐观锁和悲观锁的区别&quot;">​</a></h3><table><thead><tr><th>特性</th><th>悲观锁（Pessimistic Lock）</th><th>乐观锁（Optimistic Lock）</th></tr></thead><tbody><tr><td>锁策略</td><td>先加锁，防止并发冲突</td><td>不加锁，提交时校验是否有冲突</td></tr><tr><td>并发粒度</td><td>粒度粗，适合高冲突场景</td><td>粒度细，适合读多写少的场景</td></tr><tr><td>实现机制</td><td>依赖数据库或 JVM 的<strong>互斥锁机制</strong></td><td>依赖版本号（<code>version</code>）或 CAS（原子操作）</td></tr><tr><td>阻塞行为</td><td>线程可能被阻塞</td><td>不会阻塞，冲突时重试</td></tr><tr><td>性能</td><td>开销大，影响并发性能</td><td>性能高，但有可能多次重试导致失败</td></tr><tr><td>应用场景</td><td>银行转账、订单扣库存（强一致性要求）</td><td>表单编辑、抢票系统（最终一致性、冲突概率低）</td></tr><tr><td>常见实现</td><td><code>synchronized</code>、<code>ReentrantLock</code>、DB行锁</td><td>CAS、<code>AtomicInteger</code>、版本号字段、数据库字段版本控制</td></tr></tbody></table><h3 id="synchronized可重入的原理" tabindex="-1">Synchronized可重入的原理 <a class="header-anchor" href="#synchronized可重入的原理" aria-label="Permalink to &quot;Synchronized可重入的原理&quot;">​</a></h3><p><strong>重入锁是指一个线程获取到该锁之后，该线程可以继续获得其他锁。</strong> 底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p><h3 id="synchronized的实现原理" tabindex="-1">Synchronized的实现原理 <a class="header-anchor" href="#synchronized的实现原理" aria-label="Permalink to &quot;Synchronized的实现原理&quot;">​</a></h3><p>synchronized 是基于 JVM 层的 Monitor（监视器锁） 实现的， 通过 对象头中的 Mark Word + Monitor 对象 + 内置锁机制，实现线程间互斥、可重入和同步。</p><h3 id="锁升级" tabindex="-1">锁升级 <a class="header-anchor" href="#锁升级" aria-label="Permalink to &quot;锁升级&quot;">​</a></h3><p><img src="'+r+'" alt="f68a6daf840517f970a5cdefb00a801e_MD5.png"></p><h3 id="volatile和synchronized的区别" tabindex="-1">volatile和Synchronized的区别 <a class="header-anchor" href="#volatile和synchronized的区别" aria-label="Permalink to &quot;volatile和Synchronized的区别&quot;">​</a></h3><ul><li>volatile本质是保证变量的可见性，只能在变量级别使用，synchronize可以在方法，变量，对象上使用</li><li>volatile只能保证变量可见性，不能保证原子下，synchronize可以都保证（只有当前线程能使用，其他线程需要等待）</li><li>volatile会让当前对象会不会被编译器优化，不会进行指令重排序</li><li>volatile不会造成线程阻塞，synchronize会造成线程阻塞</li></ul><h3 id="synchronized和lock的区别" tabindex="-1">Synchronized和lock的区别 <a class="header-anchor" href="#synchronized和lock的区别" aria-label="Permalink to &quot;Synchronized和lock的区别&quot;">​</a></h3><p>1.首先<strong>synchronized是java内置关键字</strong>，在jvm层面，<strong>Lock是个java类</strong>；</p><p>2.<strong>synchronized无法判断是否获取锁的状态</strong>，<strong>Lock可以判断是否获取到锁</strong>；</p><p>3.<strong>synchronized会自动释放锁</strong>(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，* <em>Lock需在finally中手工释放锁（unlock()方法释放锁</em>*），否则容易造成线程死锁；</p><p>4.<strong>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去</strong>，而* <em>Lock锁就不一定会等待下去</em>*，如果尝试获取不到锁，线程可以不用一直等待就结束了；</p><p>5.<strong>synchronized的锁可重入、不可中断、非公平</strong>，而<strong>Lock锁可重入、可判断、可公平可非公平</strong>（两者皆可）</p><p>6.<strong>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题</strong>。</p><h3 id="java中cas的实现原理" tabindex="-1">Java中CAS的实现原理 <a class="header-anchor" href="#java中cas的实现原理" aria-label="Permalink to &quot;Java中CAS的实现原理&quot;">​</a></h3><p>CAS 是一种原子操作机制，Java 中通过 Unsafe 类调用底层 CPU 原子指令（如 CMPXCHG）实现。它通过比较当前值和预期值是否相同来决定是否更新变量，常用于实现无锁的并发类，如 AtomicInteger。虽然 CAS 性能高，但也存在 ABA 问题、自旋浪费等缺点。</p><h3 id="aqs-非阻塞队列-原理" tabindex="-1">AQS（非阻塞队列）原理 <a class="header-anchor" href="#aqs-非阻塞队列-原理" aria-label="Permalink to &quot;AQS（非阻塞队列）原理&quot;">​</a></h3><p>AQS 是 J.U.C（java.util.concurrent）并发包的核心同步框架，用来构建各种同步器（如 ReentrantLock、CountDownLatch、Semaphore），通过一个 基于 FIFO 的 CLH 队列 实现线程的排队等待。</p><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><code>state</code></td><td>表示同步状态（一个 int），如锁是否被占、计数、许可等</td></tr><tr><td><code>Node</code></td><td>内部静态类，封装了每个等待线程的信息（线程、等待状态、前驱后继）</td></tr><tr><td><code>CLH 队列</code></td><td>FIFO 队列（双向链表），线程获取锁失败后进入该队列</td></tr><tr><td><code>acquire()</code></td><td>获取同步状态，不成功则排队阻塞等待</td></tr><tr><td><code>release()</code></td><td>释放锁，唤醒下一个节点的线程</td></tr><tr><td><code>tryAcquire()</code></td><td>尝试获取锁，由具体实现类重写</td></tr><tr><td><code>tryRelease()</code></td><td>尝试释放锁，由具体实现类重写</td></tr></tbody></table><h3 id="reentrantlock的公平锁和非公平锁" tabindex="-1">ReentrantLock的公平锁和非公平锁 <a class="header-anchor" href="#reentrantlock的公平锁和非公平锁" aria-label="Permalink to &quot;ReentrantLock的公平锁和非公平锁&quot;">​</a></h3><ul><li>公平锁指的是 线程A持有锁，BCD在等待队列中，此时新增E线程，当A释放锁的时候，B线程会先获取锁，E会排到队列的最后面。</li><li>非公平锁指的是 线程A持有锁，BCD在等待队列中，此时新增E线程， 当A释放锁的时候，B和E线程会同时进行compareAndSetState操作，E线程可能会先获取锁，B线程继续在队列前面等待。</li></ul><h3 id="reentrantlock和synchronized的区别" tabindex="-1">ReentrantLock和Synchronized的区别 <a class="header-anchor" href="#reentrantlock和synchronized的区别" aria-label="Permalink to &quot;ReentrantLock和Synchronized的区别&quot;">​</a></h3><table><thead><tr><th>特性</th><th><code>synchronized</code></th><th><code>ReentrantLock</code></th></tr></thead><tbody><tr><td>实现方式</td><td>JVM 内部实现（monitor）</td><td>JDK 实现（AQS）</td></tr><tr><td>是否可中断</td><td>❌ 否</td><td>✅ 支持 lockInterruptibly()</td></tr><tr><td>是否公平锁</td><td>❌ 否（无控制）</td><td>✅ 可指定公平或非公平</td></tr><tr><td>是否支持条件变量</td><td>❌ 否（需 wait/notify）</td><td>✅ 支持 Condition，精准唤醒</td></tr><tr><td>是否必须释放锁</td><td>❌ JVM 自动释放</td><td>✅ 必须手动 unlock()，易出错</td></tr><tr><td>可重入性</td><td>✅ 支持</td><td>✅ 支持</td></tr></tbody></table><h3 id="reentrantlock的锁的可重入性" tabindex="-1">ReentrantLock的锁的可重入性 <a class="header-anchor" href="#reentrantlock的锁的可重入性" aria-label="Permalink to &quot;ReentrantLock的锁的可重入性&quot;">​</a></h3><p><img src="'+n+'" alt=""> 在当前线程获取锁时，计数器加一，如果当前线程再次获取锁，计数器继续加一，此时实现了可重入性。</p><h3 id="reentrantlock的condition的工作原理" tabindex="-1">ReentrantLock的Condition的工作原理 <a class="header-anchor" href="#reentrantlock的condition的工作原理" aria-label="Permalink to &quot;ReentrantLock的Condition的工作原理&quot;">​</a></h3><p>有Condition的时候，此时线程会加入到Condition的等待队列中，等待被唤醒。 被唤醒之后，线程不是立即执行任务，线程会重新加入到AQS的同步队列中，重新竞争锁。</p><table><thead><tr><th>关键词</th><th>内容</th></tr></thead><tbody><tr><td><code>Condition</code></td><td>类似 <code>Object.wait/notify</code>，但支持多个条件队列</td></tr><tr><td><code>await()</code></td><td>当前线程挂起，并释放锁，加入等待队列</td></tr><tr><td><code>signal()</code></td><td>唤醒一个等待线程（搬到 AQS 队列重新竞争锁）</td></tr><tr><td>多等待队列</td><td>支持多个 <code>Condition</code>，实现更复杂的同步逻辑</td></tr><tr><td>核心机制</td><td>ConditionQueue + AQS 的 SyncQueue 协同工作</td></tr></tbody></table><h3 id="threadlocal作用" tabindex="-1">ThreadLocal作用 <a class="header-anchor" href="#threadlocal作用" aria-label="Permalink to &quot;ThreadLocal作用&quot;">​</a></h3><p>ThreadLocal 是 Java 提供的一个线程局部变量机制，用于在多线程环境中为每个线程提供独立的变量副本。每个线程可以通过 ThreadLocal 对象访问自己的副本，而不会影响其他线程的副本。 ThreadLocal 的作用包括：</p><ol><li><strong>线程隔离</strong>：每个线程都有自己的变量副本，避免了多线程之间的共享数据冲突。</li><li><strong>简化代码</strong>：可以避免使用显式的同步机制（如锁）来保护共享数据，减少了代码复杂性。</li><li><strong>性能优化</strong>：在某些场景下，ThreadLocal 可以提高性能，因为它避免了锁的开销。</li><li><strong>存储线程上下文信息</strong>：可以用于存储与线程相关的上下文信息，如用户会话、数据库连接等。</li><li><strong>避免传递参数</strong>：在需要频繁传递相同参数的情况下，可以使用 ThreadLocal 来存储这些参数，减少方法调用的复杂性。</li></ol><h3 id="threadlocal的工作原理" tabindex="-1">ThreadLocal的工作原理 <a class="header-anchor" href="#threadlocal的工作原理" aria-label="Permalink to &quot;ThreadLocal的工作原理&quot;">​</a></h3><p>ThreadLocal 的工作原理是通过每个线程维护一个 ThreadLocalMap 来存储线程局部变量。每个 ThreadLocal 对象作为 key， 对应的线程局部变量作为 value 存储在 ThreadLocalMap 中。每个线程都有自己的 ThreadLocalMap， 因此每个线程可以独立地访问和修改自己的变量副本。</p><h3 id="threadlocal的内存泄漏问题" tabindex="-1">ThreadLocal的内存泄漏问题 <a class="header-anchor" href="#threadlocal的内存泄漏问题" aria-label="Permalink to &quot;ThreadLocal的内存泄漏问题&quot;">​</a></h3><p>ThreadLocal虽然key是弱引用，会被gc回收， 但是value是强引用，所以如果ThreadLocal对象没有被清理掉，value就会一直存在，导致内存泄漏。</p><h3 id="如何跨线程传递threadlocal值" tabindex="-1">如何跨线程传递ThreadLocal值 <a class="header-anchor" href="#如何跨线程传递threadlocal值" aria-label="Permalink to &quot;如何跨线程传递ThreadLocal值&quot;">​</a></h3><p>可以通过以下方式跨线程传递 ThreadLocal 值：</p><ol><li><strong>手动传递</strong>：在需要传递 ThreadLocal 值的线程中，先获取当前线程的 ThreadLocal 值，然后在新线程中设置该值。</li><li><strong>使用继承</strong>：创建一个新的 ThreadLocal 子类，重写 <code>initialValue()</code> 方法，在新线程中调用父类的 <code>get()</code> 方法获取值。</li><li><strong>使用 ExecutorService</strong>：在提交任务时，将 ThreadLocal 值作为参数传递给任务，任务内部可以直接使用该值。</li></ol><h3 id="常见的线程池类型" tabindex="-1">常见的线程池类型 <a class="header-anchor" href="#常见的线程池类型" aria-label="Permalink to &quot;常见的线程池类型&quot;">​</a></h3><table><thead><tr><th>线程池类型</th><th>方法</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>固定线程池</strong><br>FixedThreadPool</td><td><code>Executors.newFixedThreadPool(n)</code></td><td>- 线程数量固定，便于控制资源<br>- 线程可复用，效率高</td><td>- 队列是<strong>无界队列</strong>，任务太多可能导致 OOM</td><td>稳定并发任务，如文件处理、日志上传等</td></tr><tr><td><strong>单线程池</strong><br>SingleThreadExecutor</td><td><code>Executors.newSingleThreadExecutor()</code></td><td>- 保证任务按顺序执行<br>- 线程复用，资源消耗小</td><td>- 单线程执行，任务慢时会<strong>拖垮所有任务</strong><br>- 同样使用<strong>无界队列</strong>，易 OOM</td><td>串行任务，关键任务串行执行</td></tr><tr><td><strong>可缓存线程池</strong><br>CachedThreadPool</td><td><code>Executors.newCachedThreadPool()</code></td><td>- 弹性强，短期任务处理能力强<br>- 空闲线程自动释放</td><td>- <strong>最大线程数无限</strong>，并发高峰时可能创建太多线程→ OOM</td><td>短时间并发量大，如消息推送、IO密集型任务</td></tr><tr><td><strong>定时任务线程池</strong><br>ScheduledThreadPool</td><td><code>Executors.newScheduledThreadPool(n)</code></td><td>- 支持<strong>延迟/周期</strong>执行任务</td><td>- 定时任务执行时间不可控，<strong>可能任务堆积</strong><br>- 非真实时间任务调度（非硬实时）</td><td>定时轮询、日志归档、心跳检查等</td></tr><tr><td><strong>工作窃取线程池</strong><br>WorkStealingPool</td><td><code>Executors.newWorkStealingPool()</code></td><td>- 利用多核优势，支持任务分治<br>- 动态调度、负载均衡好</td><td>- JDK 8+ 才有<br>- 无法控制线程数量<br>- <strong>非显式管理</strong>（ForkJoinPool 内部）</td><td>多核 CPU 密集型并行任务，如图像处理、递归拆分</td></tr></tbody></table><h3 id="为什么不推荐使用内置线程池" tabindex="-1">为什么不推荐使用内置线程池 <a class="header-anchor" href="#为什么不推荐使用内置线程池" aria-label="Permalink to &quot;为什么不推荐使用内置线程池&quot;">​</a></h3><ul><li>newFixedThreadPool(): 无界队列，任务堆积不拒绝，可能 OOM</li><li>newCachedThreadPool(): 线程池的线程数量没有限制，可能导致系统资源耗尽。无限最大线程数 ➝ OOM 极高风险</li><li>newSingleThreadExecutor(): 只能处理单线程任务，无法利用多核 CPU 的优势。队列无界，任务积压严重 ➝ OOM</li><li>newScheduledThreadPool(): 任务调度不够灵活，无法满足复杂的定时任务需求。长时间堆积任务可能内存泄漏</li><li>newWorkStealingPool(): 需要 JDK 8+，且不支持显式管理线程池。</li></ul><h3 id="线程池的7大参数" tabindex="-1">线程池的7大参数 <a class="header-anchor" href="#线程池的7大参数" aria-label="Permalink to &quot;线程池的7大参数&quot;">​</a></h3><table><thead><tr><th>参数名称</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程数，线程池中始终保持的线程数量。核心线程会一直存活，除非设置了 allowCoreThreadTimeOut。</td><td>1</td></tr><tr><td>maximumPoolSize</td><td>最大线程数，线程池允许的最大线程数量。超过核心线程数的线程会被回收。</td><td>Integer.MAX_VALUE</td></tr><tr><td>keepAliveTime</td><td>非核心线程的存活时间，当线程空闲超过该时间后会被回收。单位为秒。</td><td>60</td></tr><tr><td>unit</td><td>keepAliveTime 的时间单位。可以是 SECONDS、MILLISECONDS 等。</td><td>TimeUnit.SECONDS</td></tr><tr><td>workQueue</td><td>任务队列，用于存放等待执行的任务。可以是无界队列（如 LinkedBlockingQueue）或有界队列（如 ArrayBlockingQueue）。</td><td>LinkedBlockingQueue</td></tr><tr><td>threadFactory</td><td>线程工厂，用于创建新线程。可以自定义线程名称、优先级等。</td><td>Executors.defaultThreadFactory()</td></tr><tr><td>handler</td><td>拒绝策略，当线程池和队列都满了时，如何处理新提交的任务。可以是 AbortPolicy、CallerRunsPolicy、DiscardPolicy、DiscardOldestPolicy 等。</td><td>AbortPolicy</td></tr></tbody></table><h3 id="线程池的拒绝策略" tabindex="-1">线程池的拒绝策略 <a class="header-anchor" href="#线程池的拒绝策略" aria-label="Permalink to &quot;线程池的拒绝策略&quot;">​</a></h3><table><thead><tr><th>拒绝策略名称</th><th>说明</th><th>适用场景</th></tr></thead><tbody><tr><td>AbortPolicy</td><td>抛出 RejectedExecutionException 异常，默认策略。适用于不允许任务丢失的场景。</td><td>任务必须被处理，不能丢失或忽略。</td></tr><tr><td>CallerRunsPolicy</td><td>由调用线程处理该任务，当前线程执行任务而不是提交到线程池。适用于任务量较小或可以容忍延迟的场景。</td><td>任务量小，允许调用线程处理任务。</td></tr><tr><td>DiscardPolicy</td><td>丢弃新提交的任务，不抛出异常。适用于可以容忍任务丢失的场景。</td><td>任务不重要，可以丢弃。</td></tr><tr><td>DiscardOldestPolicy</td><td>丢弃队列中最旧的任务，然后尝试提交当前任务。适用于可以丢弃旧任务的场景。</td><td>任务量大，允许丢弃旧任务。</td></tr></tbody></table><h3 id="线程池处理任务的流程" tabindex="-1">线程池处理任务的流程 <a class="header-anchor" href="#线程池处理任务的流程" aria-label="Permalink to &quot;线程池处理任务的流程&quot;">​</a></h3><p><img src="'+o+`" alt="线程池处理任务流程"></p><h3 id="线程池的核心线程数和最大线程数的区别" tabindex="-1">线程池的核心线程数和最大线程数的区别 <a class="header-anchor" href="#线程池的核心线程数和最大线程数的区别" aria-label="Permalink to &quot;线程池的核心线程数和最大线程数的区别&quot;">​</a></h3><ul><li>当前已有 2 个核心线程；</li><li>如果再来任务，先塞进队列（最多 3 个任务）；</li><li>如果队列也满了，线程池可扩容到最多 5 个线程；</li><li>超过 5 还是来任务，就会触发拒绝策略。</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ThreadPoolExecutor executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadPoolExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// corePoolSize</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// maximumPoolSize</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, TimeUnit.SECONDS,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinkedBlockingQueue&lt;&gt;(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="线程池中线程异常后是销毁还是复用" tabindex="-1">线程池中线程异常后是销毁还是复用 <a class="header-anchor" href="#线程池中线程异常后是销毁还是复用" aria-label="Permalink to &quot;线程池中线程异常后是销毁还是复用&quot;">​</a></h3><p>如果线程池中执行任务的线程抛出异常，线程会被销毁，不会复用。线程池会根据需要创建新的线程来替代被销毁的线程，以确保线程池中的线程数量保持在核心线程数和最大线程数之间。 但是异常的任务如果被捕获并处理掉，线程不会被销毁，线程池中的线程会继续复用。</p><h3 id="线程池大小如何设定" tabindex="-1">线程池大小如何设定 <a class="header-anchor" href="#线程池大小如何设定" aria-label="Permalink to &quot;线程池大小如何设定&quot;">​</a></h3><p>IO密集型任务：线程数 = CPU核数 / (1 - 阻塞系数)，阻塞系数一般取0.8~0.9 CPU密集型任务：线程数 = CPU核数 + 1 或 CPU核数 * 2</p><h3 id="如何动态修改线程池的参数" tabindex="-1">如何动态修改线程池的参数 <a class="header-anchor" href="#如何动态修改线程池的参数" aria-label="Permalink to &quot;如何动态修改线程池的参数&quot;">​</a></h3><p>可以通过 ThreadPoolExecutor 提供的 setCorePoolSize()、setMaximumPoolSize()、setKeepAliveTime() 等方法动态修改线程池的参数。</p><h2 id="jvm" tabindex="-1">JVM <a class="header-anchor" href="#jvm" aria-label="Permalink to &quot;JVM&quot;">​</a></h2><h3 id="jvm的内存模型" tabindex="-1">JVM的内存模型 <a class="header-anchor" href="#jvm的内存模型" aria-label="Permalink to &quot;JVM的内存模型&quot;">​</a></h3><p><img src="`+d+'" alt="内存模型"></p><ol><li>线程共享区域 <ul><li>堆(heap):线程共享的内存区域，存放对象实例和数组。回收器主要的管理对象</li><li>方法区(Method Area):线程共享的内存区域，存放类信息、常量、静态变量等。也称为永久代(PermGen)或元空间(Metaspace)。</li></ul></li><li>线程独享区域 <ul><li>栈(Stack):每个线程独立的内存区域，存放局部变量、操作数栈、动态链接等。每个方法调用都会创建一个栈帧(Frame)。</li><li>本地方法栈(Native Method Stack):存放本地方法调用的栈帧，与 Java 栈类似。</li><li>程序计数器(Program Counter Register):每个线程独立的内存区域，记录当前线程执行的字节码指令地址。用于线程切换时恢复执行位置。</li></ul></li></ol><h3 id="jvm中的类加载过程" tabindex="-1">JVM中的类加载过程 <a class="header-anchor" href="#jvm中的类加载过程" aria-label="Permalink to &quot;JVM中的类加载过程&quot;">​</a></h3><ol><li><strong>加载(Loading)</strong>：将类的字节码从文件或网络加载到内存中，生成一个 Class 对象。</li><li><strong>链接(Linking)</strong>： <ul><li><strong>验证(Verification)</strong>：检查字节码的正确性，确保符合 JVM 规范。</li><li><strong>准备(Preparation)</strong>：为类的静态变量分配内存，并设置默认值。</li><li><strong>解析(Resolution)</strong>：将类中的符号引用转换为直接引用（如方法、字段等）。</li></ul></li><li><strong>初始化(Initialization)</strong>：执行类的静态初始化块和静态变量的赋值操作，完成类的初始化。</li><li><strong>使用(Using)</strong>：类被加载并初始化后，可以被应用程序使用。</li><li><strong>卸载(Unloading)</strong>：当类不再被使用时，JVM 可以将其从内存中卸载，释放资源。</li></ol><h3 id="类加载器-双亲委派" tabindex="-1">类加载器(双亲委派) <a class="header-anchor" href="#类加载器-双亲委派" aria-label="Permalink to &quot;类加载器(双亲委派)&quot;">​</a></h3><ol><li>当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。</li><li>当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li><li>如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；</li><li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li></ol><h3 id="什么时候破坏了双亲委派模型" tabindex="-1">什么时候破坏了双亲委派模型 <a class="header-anchor" href="#什么时候破坏了双亲委派模型" aria-label="Permalink to &quot;什么时候破坏了双亲委派模型&quot;">​</a></h3><p>当一个类加载器在加载类时，直接尝试加载该类，而不通过父类加载器进行委派时，就破坏了双亲委派模型。这通常发生在以下情况：</p><ul><li><strong>自定义类加载器</strong>：如果自定义类加载器在加载类时，直接调用 <code>findClass()</code> 方法，而不先调用</li><li><code>loadClass()</code> 方法，则会破坏双亲委派模型。</li><li><strong>使用 <code>defineClass()</code> 方法</strong>：如果直接使用 <code>defineClass()</code> 方法加载类，而不通过父类加载器进行委派，也会破坏双亲委派模型。</li><li><strong>使用 <code>Class.forName()</code> 方法</strong>：如果在自定义类加载器中使用 <code>Class.forName()</code> 方法加载类，而不通过父类加载器进行委派，也会破坏双亲委派模型。</li><li><strong>使用 <code>Thread.currentThread().getContextClassLoader()</code></strong>：如果在加载类时，使用当前线程的上下文类加载器，而不是父类加载器，也会破坏双亲委派模型。</li></ul><h3 id="如何判断一个对象可以回收" tabindex="-1">如何判断一个对象可以回收 <a class="header-anchor" href="#如何判断一个对象可以回收" aria-label="Permalink to &quot;如何判断一个对象可以回收&quot;">​</a></h3><ol><li>根可达性分析算法：从 GC Roots 开始，遍历对象图，判断哪些对象是可达的。不可达的对象会被回收。</li><li>引用计数算法：每个对象维护一个引用计数器，当有引用指向该对象时，计数器加一；当引用被移除时，计数器减一。当计数器为零时，对象可以被回收。此方法无法处理循环引用。</li></ol><h3 id="垃圾回收算法" tabindex="-1">垃圾回收算法 <a class="header-anchor" href="#垃圾回收算法" aria-label="Permalink to &quot;垃圾回收算法&quot;">​</a></h3><ol><li><strong>标记-清除算法</strong>：分为两个阶段，标记阶段标记所有需要回收的对象，清除阶段清除被标记的对象。缺点是会产生内存碎片。</li><li><strong>复制算法</strong>：将内存分为两块，每次只使用一块，复制存活对象到另一块内存中，清除原来的内存。优点是没有内存碎片，但需要额外的内存空间。</li><li><strong>标记-整理算法</strong>：类似于标记-清除算法，但在清除阶段将存活对象移动到内存的一端，整理内存空间，避免碎片。</li></ol><h3 id="垃圾收集器" tabindex="-1">垃圾收集器 <a class="header-anchor" href="#垃圾收集器" aria-label="Permalink to &quot;垃圾收集器&quot;">​</a></h3><ol><li><strong>Serial 收集器</strong>：单线程，适用于单核 CPU 或小型应用，使用标记-清除算法。</li><li><strong>Parallel 收集器</strong>：多线程，适用于多核 CPU，使用复制算法，适合大多数应用。</li><li><strong>CMS（Concurrent Mark-Sweep）收集器</strong>：并发标记-清除算法，适用于低延迟应用，减少停顿时间，但会产生内存碎片。</li><li><strong>G1（Garbage-First）收集器</strong>：分代收集器，适用于大内存应用，使用分区算法，目标是减少停顿时间和内存碎片。</li><li><strong>ZGC（Z Garbage Collector）</strong>：低延迟收集器，支持大内存，使用分区算法，目标是几乎无停顿时间。</li></ol><h3 id="jvm中的对象在堆中的生命周期" tabindex="-1">JVM中的对象在堆中的生命周期 <a class="header-anchor" href="#jvm中的对象在堆中的生命周期" aria-label="Permalink to &quot;JVM中的对象在堆中的生命周期&quot;">​</a></h3><ol><li>创建对象的时候会优先放入Eden区，大对象会直接放入老年代（Tenured）</li><li>当Eden区满了，触发Minor GC，将存活的对象移动到Survivor区</li><li>经过多次Minor GC后(默认15次)，存活的对象会被移动到老年代（Tenured）</li><li>当对象在老年代存活时间超过阈值或者不再被引用，可能会被标记为可回收</li></ol><h3 id="什么时候触发full-gc" tabindex="-1">什么时候触发Full GC <a class="header-anchor" href="#什么时候触发full-gc" aria-label="Permalink to &quot;什么时候触发Full GC&quot;">​</a></h3><ol><li>老年代空间不足: 对象晋升或分配大对象</li><li>系统执行system.gc()或Runtime.getRuntime().gc()请求</li><li>元空间不足: 类加载器无法加载新类</li><li>新生代GC失败</li></ol><h3 id="处理线上oom的过程" tabindex="-1">处理线上oom的过程 <a class="header-anchor" href="#处理线上oom的过程" aria-label="Permalink to &quot;处理线上oom的过程&quot;">​</a></h3><blockquote><p>一般出现oom都是大任务的定时任务，excel导出等任务，或者是大数据量的查询等。</p></blockquote><ol><li>导出堆转储文件（Heap Dump），使用 jmap 或 jcmd 命令。</li><li>重启应用，避免继续占用内存。</li><li>分析dump文件，使用工具如 Eclipse MAT、VisualVM 等。</li><li>定位内存泄漏或高内存占用的对象，查看对象引用链。</li></ol><h2 id="spring" tabindex="-1">Spring <a class="header-anchor" href="#spring" aria-label="Permalink to &quot;Spring&quot;">​</a></h2><h3 id="spring的ioc概念及如何实现" tabindex="-1">Spring的IOC概念及如何实现 <a class="header-anchor" href="#spring的ioc概念及如何实现" aria-label="Permalink to &quot;Spring的IOC概念及如何实现&quot;">​</a></h3><h3 id="spring的bean作用域的概念" tabindex="-1">Spring的Bean作用域的概念 <a class="header-anchor" href="#spring的bean作用域的概念" aria-label="Permalink to &quot;Spring的Bean作用域的概念&quot;">​</a></h3><h3 id="spring的bean的生命周期" tabindex="-1">Spring的Bean的生命周期 <a class="header-anchor" href="#spring的bean的生命周期" aria-label="Permalink to &quot;Spring的Bean的生命周期&quot;">​</a></h3><h3 id="bean是线程安全吗" tabindex="-1">Bean是线程安全吗 <a class="header-anchor" href="#bean是线程安全吗" aria-label="Permalink to &quot;Bean是线程安全吗&quot;">​</a></h3><h3 id="spring的aop概念及如何实现" tabindex="-1">Spring的AOP概念及如何实现 <a class="header-anchor" href="#spring的aop概念及如何实现" aria-label="Permalink to &quot;Spring的AOP概念及如何实现&quot;">​</a></h3><h3 id="jdk动态代理和cglib的区别" tabindex="-1">JDK动态代理和CGLIB的区别 <a class="header-anchor" href="#jdk动态代理和cglib的区别" aria-label="Permalink to &quot;JDK动态代理和CGLIB的区别&quot;">​</a></h3><h3 id="spring的事务传播行为" tabindex="-1">Spring的事务传播行为 <a class="header-anchor" href="#spring的事务传播行为" aria-label="Permalink to &quot;Spring的事务传播行为&quot;">​</a></h3><h3 id="spring的事务什么时候会失效" tabindex="-1">Spring的事务什么时候会失效 <a class="header-anchor" href="#spring的事务什么时候会失效" aria-label="Permalink to &quot;Spring的事务什么时候会失效&quot;">​</a></h3><h3 id="spring如何解决循环依赖-不使用三级缓存是否可以" tabindex="-1">Spring如何解决循环依赖（不使用三级缓存是否可以） <a class="header-anchor" href="#spring如何解决循环依赖-不使用三级缓存是否可以" aria-label="Permalink to &quot;Spring如何解决循环依赖（不使用三级缓存是否可以）&quot;">​</a></h3><h3 id="spring中使用的设计模式" tabindex="-1">Spring中使用的设计模式 <a class="header-anchor" href="#spring中使用的设计模式" aria-label="Permalink to &quot;Spring中使用的设计模式&quot;">​</a></h3><h3 id="如果让你实现一个spring容器-你会怎么做" tabindex="-1">如果让你实现一个spring容器，你会怎么做 <a class="header-anchor" href="#如果让你实现一个spring容器-你会怎么做" aria-label="Permalink to &quot;如果让你实现一个spring容器，你会怎么做&quot;">​</a></h3><h2 id="springmvc" tabindex="-1">SpringMVC <a class="header-anchor" href="#springmvc" aria-label="Permalink to &quot;SpringMVC&quot;">​</a></h2><h3 id="springmvc的请求处理流程" tabindex="-1">SpringMVC的请求处理流程 <a class="header-anchor" href="#springmvc的请求处理流程" aria-label="Permalink to &quot;SpringMVC的请求处理流程&quot;">​</a></h3><h3 id="springmvc的核心组件" tabindex="-1">SpringMVC的核心组件 <a class="header-anchor" href="#springmvc的核心组件" aria-label="Permalink to &quot;SpringMVC的核心组件&quot;">​</a></h3><h2 id="springboot" tabindex="-1">SpringBoot <a class="header-anchor" href="#springboot" aria-label="Permalink to &quot;SpringBoot&quot;">​</a></h2><h3 id="springboot的自动配置原理" tabindex="-1">SpringBoot的自动配置原理 <a class="header-anchor" href="#springboot的自动配置原理" aria-label="Permalink to &quot;SpringBoot的自动配置原理&quot;">​</a></h3><h3 id="springboot的starter自定义实现" tabindex="-1">SpringBoot的starter自定义实现 <a class="header-anchor" href="#springboot的starter自定义实现" aria-label="Permalink to &quot;SpringBoot的starter自定义实现&quot;">​</a></h3><h2 id="mybatis" tabindex="-1">Mybatis <a class="header-anchor" href="#mybatis" aria-label="Permalink to &quot;Mybatis&quot;">​</a></h2><h3 id="和-的区别" tabindex="-1"><code>#</code>和<code>$</code>的区别 <a class="header-anchor" href="#和-的区别" aria-label="Permalink to &quot;`#`和`$`的区别&quot;">​</a></h3><h3 id="xml映射文件中常见标签及其作用" tabindex="-1">XML映射文件中常见标签及其作用 <a class="header-anchor" href="#xml映射文件中常见标签及其作用" aria-label="Permalink to &quot;XML映射文件中常见标签及其作用&quot;">​</a></h3><h3 id="dao的接口工作原理-dao接口的方法参数不同-方法能够重载" tabindex="-1">Dao的接口工作原理，Dao接口的方法参数不同，方法能够重载 <a class="header-anchor" href="#dao的接口工作原理-dao接口的方法参数不同-方法能够重载" aria-label="Permalink to &quot;Dao的接口工作原理，Dao接口的方法参数不同，方法能够重载&quot;">​</a></h3><h3 id="mybatis如何进行分页" tabindex="-1">Mybatis如何进行分页 <a class="header-anchor" href="#mybatis如何进行分页" aria-label="Permalink to &quot;Mybatis如何进行分页&quot;">​</a></h3><h3 id="mybatis的插件运行原理" tabindex="-1">Mybatis的插件运行原理 <a class="header-anchor" href="#mybatis的插件运行原理" aria-label="Permalink to &quot;Mybatis的插件运行原理&quot;">​</a></h3><h3 id="mybatis的延迟加载" tabindex="-1">Mybatis的延迟加载 <a class="header-anchor" href="#mybatis的延迟加载" aria-label="Permalink to &quot;Mybatis的延迟加载&quot;">​</a></h3><h3 id="mybatis的缓存机制-以及为什么不开启二级缓存" tabindex="-1">Mybatis的缓存机制，以及为什么不开启二级缓存 <a class="header-anchor" href="#mybatis的缓存机制-以及为什么不开启二级缓存" aria-label="Permalink to &quot;Mybatis的缓存机制，以及为什么不开启二级缓存&quot;">​</a></h3><h2 id="mysql" tabindex="-1">MySQL <a class="header-anchor" href="#mysql" aria-label="Permalink to &quot;MySQL&quot;">​</a></h2><h3 id="mysql文件后缀" tabindex="-1">MySQL文件后缀 <a class="header-anchor" href="#mysql文件后缀" aria-label="Permalink to &quot;MySQL文件后缀&quot;">​</a></h3><h3 id="mysql的存储引擎-innodb和myisam" tabindex="-1">MySQL的存储引擎(InnoDB和MyISAM) <a class="header-anchor" href="#mysql的存储引擎-innodb和myisam" aria-label="Permalink to &quot;MySQL的存储引擎(InnoDB和MyISAM)&quot;">​</a></h3><h3 id="mysql为什么使用b-树-而不是红黑树-二叉树-hashmap" tabindex="-1">MySQL为什么使用B+树，而不是红黑树，二叉树，hashMap <a class="header-anchor" href="#mysql为什么使用b-树-而不是红黑树-二叉树-hashmap" aria-label="Permalink to &quot;MySQL为什么使用B+树，而不是红黑树，二叉树，hashMap&quot;">​</a></h3><h3 id="mysql的事务隔离级别" tabindex="-1">MySQL的事务隔离级别 <a class="header-anchor" href="#mysql的事务隔离级别" aria-label="Permalink to &quot;MySQL的事务隔离级别&quot;">​</a></h3><h3 id="redo-log为什么可以实现事务的原子性和持久性。" tabindex="-1">redo log为什么可以实现事务的原子性和持久性。 <a class="header-anchor" href="#redo-log为什么可以实现事务的原子性和持久性。" aria-label="Permalink to &quot;redo log为什么可以实现事务的原子性和持久性。&quot;">​</a></h3><h2 id="binlog和redo-log的区别" tabindex="-1">Binlog和redo log的区别 <a class="header-anchor" href="#binlog和redo-log的区别" aria-label="Permalink to &quot;Binlog和redo log的区别&quot;">​</a></h2><h3 id="mysql如何实现mvcc" tabindex="-1">MySQL如何实现MVCC <a class="header-anchor" href="#mysql如何实现mvcc" aria-label="Permalink to &quot;MySQL如何实现MVCC&quot;">​</a></h3><h3 id="mysql的表锁和行锁的区别" tabindex="-1">MySQL的表锁和行锁的区别 <a class="header-anchor" href="#mysql的表锁和行锁的区别" aria-label="Permalink to &quot;MySQL的表锁和行锁的区别&quot;">​</a></h3><h3 id="mysql索引失效场景及解决方案" tabindex="-1">MySQl索引失效场景及解决方案 <a class="header-anchor" href="#mysql索引失效场景及解决方案" aria-label="Permalink to &quot;MySQl索引失效场景及解决方案&quot;">​</a></h3><h3 id="什么是回表查询-为什么会发生回表查询" tabindex="-1">什么是回表查询，为什么会发生回表查询 <a class="header-anchor" href="#什么是回表查询-为什么会发生回表查询" aria-label="Permalink to &quot;什么是回表查询，为什么会发生回表查询&quot;">​</a></h3><h3 id="char和varchar的区别" tabindex="-1">char和varchar的区别 <a class="header-anchor" href="#char和varchar的区别" aria-label="Permalink to &quot;char和varchar的区别&quot;">​</a></h3><h3 id="null和空字符串的区别" tabindex="-1">NULL和空字符串的区别 <a class="header-anchor" href="#null和空字符串的区别" aria-label="Permalink to &quot;NULL和空字符串的区别&quot;">​</a></h3><h3 id="boolean类型的存储方式" tabindex="-1">Boolean类型的存储方式 <a class="header-anchor" href="#boolean类型的存储方式" aria-label="Permalink to &quot;Boolean类型的存储方式&quot;">​</a></h3><h3 id="一条sql在mysql的执行流程" tabindex="-1">一条sql在mysql的执行流程 <a class="header-anchor" href="#一条sql在mysql的执行流程" aria-label="Permalink to &quot;一条sql在mysql的执行流程&quot;">​</a></h3><h3 id="手机号-ip等数据存储选型" tabindex="-1">手机号，ip等数据存储选型 <a class="header-anchor" href="#手机号-ip等数据存储选型" aria-label="Permalink to &quot;手机号，ip等数据存储选型&quot;">​</a></h3><h2 id="redis" tabindex="-1">Redis <a class="header-anchor" href="#redis" aria-label="Permalink to &quot;Redis&quot;">​</a></h2><h3 id="redis的常见数据类型及数据类型的底层实现" tabindex="-1">Redis的常见数据类型及数据类型的底层实现 <a class="header-anchor" href="#redis的常见数据类型及数据类型的底层实现" aria-label="Permalink to &quot;Redis的常见数据类型及数据类型的底层实现&quot;">​</a></h3><h3 id="redis的持久化方式" tabindex="-1">Redis的持久化方式 <a class="header-anchor" href="#redis的持久化方式" aria-label="Permalink to &quot;Redis的持久化方式&quot;">​</a></h3><h3 id="redis的主从复制和哨兵模式" tabindex="-1">Redis的主从复制和哨兵模式 <a class="header-anchor" href="#redis的主从复制和哨兵模式" aria-label="Permalink to &quot;Redis的主从复制和哨兵模式&quot;">​</a></h3><h3 id="redis快的原因" tabindex="-1">Redis快的原因 <a class="header-anchor" href="#redis快的原因" aria-label="Permalink to &quot;Redis快的原因&quot;">​</a></h3><h3 id="redis的缓存穿透-缓存击穿-缓存雪崩" tabindex="-1">Redis的缓存穿透，缓存击穿，缓存雪崩 <a class="header-anchor" href="#redis的缓存穿透-缓存击穿-缓存雪崩" aria-label="Permalink to &quot;Redis的缓存穿透，缓存击穿，缓存雪崩&quot;">​</a></h3><h3 id="redis的分布式锁" tabindex="-1">Redis的分布式锁 <a class="header-anchor" href="#redis的分布式锁" aria-label="Permalink to &quot;Redis的分布式锁&quot;">​</a></h3><h3 id="redis实现消息队列的方式" tabindex="-1">Redis实现消息队列的方式 <a class="header-anchor" href="#redis实现消息队列的方式" aria-label="Permalink to &quot;Redis实现消息队列的方式&quot;">​</a></h3><h3 id="redis的有序集合为什么要用跳表实现-不用红黑树等其他数据结构" tabindex="-1">Redis的有序集合为什么要用跳表实现，不用红黑树等其他数据结构 <a class="header-anchor" href="#redis的有序集合为什么要用跳表实现-不用红黑树等其他数据结构" aria-label="Permalink to &quot;Redis的有序集合为什么要用跳表实现，不用红黑树等其他数据结构&quot;">​</a></h3><h3 id="redis6之后的多线程模型" tabindex="-1">Redis6之后的多线程模型 <a class="header-anchor" href="#redis6之后的多线程模型" aria-label="Permalink to &quot;Redis6之后的多线程模型&quot;">​</a></h3><h3 id="redis如何判断数据是否过期" tabindex="-1">Redis如何判断数据是否过期 <a class="header-anchor" href="#redis如何判断数据是否过期" aria-label="Permalink to &quot;Redis如何判断数据是否过期&quot;">​</a></h3><h3 id="redis的淘汰策略" tabindex="-1">Redis的淘汰策略 <a class="header-anchor" href="#redis的淘汰策略" aria-label="Permalink to &quot;Redis的淘汰策略&quot;">​</a></h3><h3 id="redis的事务" tabindex="-1">Redis的事务 <a class="header-anchor" href="#redis的事务" aria-label="Permalink to &quot;Redis的事务&quot;">​</a></h3><h3 id="redis如何保持和数据库数据一致性" tabindex="-1">Redis如何保持和数据库数据一致性 <a class="header-anchor" href="#redis如何保持和数据库数据一致性" aria-label="Permalink to &quot;Redis如何保持和数据库数据一致性&quot;">​</a></h3><h3 id="redis的cluster插槽和一致性hash算法的区别" tabindex="-1">Redis的cluster插槽和一致性hash算法的区别 <a class="header-anchor" href="#redis的cluster插槽和一致性hash算法的区别" aria-label="Permalink to &quot;Redis的cluster插槽和一致性hash算法的区别&quot;">​</a></h3><h2 id="zookeeper" tabindex="-1">Zookeeper <a class="header-anchor" href="#zookeeper" aria-label="Permalink to &quot;Zookeeper&quot;">​</a></h2><h3 id="zab协议和paxos算法" tabindex="-1">ZAB协议和Paxos算法 <a class="header-anchor" href="#zab协议和paxos算法" aria-label="Permalink to &quot;ZAB协议和Paxos算法&quot;">​</a></h3><h2 id="es" tabindex="-1">ES <a class="header-anchor" href="#es" aria-label="Permalink to &quot;ES&quot;">​</a></h2><h2 id="mq" tabindex="-1">MQ <a class="header-anchor" href="#mq" aria-label="Permalink to &quot;MQ&quot;">​</a></h2><h3 id="mq的概念" tabindex="-1">MQ的概念 <a class="header-anchor" href="#mq的概念" aria-label="Permalink to &quot;MQ的概念&quot;">​</a></h3><h3 id="mq的作用" tabindex="-1">MQ的作用 <a class="header-anchor" href="#mq的作用" aria-label="Permalink to &quot;MQ的作用&quot;">​</a></h3><h3 id="rocketmq的架构" tabindex="-1">RocketMQ的架构 <a class="header-anchor" href="#rocketmq的架构" aria-label="Permalink to &quot;RocketMQ的架构&quot;">​</a></h3><h3 id="rocketmq如何保证顺序消费和不重复消费" tabindex="-1">RocketMQ如何保证顺序消费和不重复消费 <a class="header-anchor" href="#rocketmq如何保证顺序消费和不重复消费" aria-label="Permalink to &quot;RocketMQ如何保证顺序消费和不重复消费&quot;">​</a></h3><h3 id="rocketmq的事务消息" tabindex="-1">RocketMQ的事务消息 <a class="header-anchor" href="#rocketmq的事务消息" aria-label="Permalink to &quot;RocketMQ的事务消息&quot;">​</a></h3><h2 id="分布式" tabindex="-1">分布式 <a class="header-anchor" href="#分布式" aria-label="Permalink to &quot;分布式&quot;">​</a></h2><h3 id="分布式的概念" tabindex="-1">分布式的概念 <a class="header-anchor" href="#分布式的概念" aria-label="Permalink to &quot;分布式的概念&quot;">​</a></h3><h3 id="一致性hash算法" tabindex="-1">一致性hash算法 <a class="header-anchor" href="#一致性hash算法" aria-label="Permalink to &quot;一致性hash算法&quot;">​</a></h3><h2 id="注册中心" tabindex="-1">注册中心 <a class="header-anchor" href="#注册中心" aria-label="Permalink to &quot;注册中心&quot;">​</a></h2><h2 id="rpc" tabindex="-1">RPC <a class="header-anchor" href="#rpc" aria-label="Permalink to &quot;RPC&quot;">​</a></h2><h3 id="rpc的基本原理" tabindex="-1">RPC的基本原理 <a class="header-anchor" href="#rpc的基本原理" aria-label="Permalink to &quot;RPC的基本原理&quot;">​</a></h3><h3 id="常见的rpc框架" tabindex="-1">常见的RPC框架 <a class="header-anchor" href="#常见的rpc框架" aria-label="Permalink to &quot;常见的RPC框架&quot;">​</a></h3><h3 id="dubbo的架构的核心角色" tabindex="-1">Dubbo的架构的核心角色 <a class="header-anchor" href="#dubbo的架构的核心角色" aria-label="Permalink to &quot;Dubbo的架构的核心角色&quot;">​</a></h3><h3 id="dubbo的invoker概念" tabindex="-1">Dubbo的Invoker概念 <a class="header-anchor" href="#dubbo的invoker概念" aria-label="Permalink to &quot;Dubbo的Invoker概念&quot;">​</a></h3><h3 id="dubbo的工作原理" tabindex="-1">Dubbo的工作原理 <a class="header-anchor" href="#dubbo的工作原理" aria-label="Permalink to &quot;Dubbo的工作原理&quot;">​</a></h3><h3 id="dubbo的spi机制" tabindex="-1">Dubbo的SPI机制 <a class="header-anchor" href="#dubbo的spi机制" aria-label="Permalink to &quot;Dubbo的SPI机制&quot;">​</a></h3><h3 id="dubbo的负载均衡策略" tabindex="-1">Dubbo的负载均衡策略 <a class="header-anchor" href="#dubbo的负载均衡策略" aria-label="Permalink to &quot;Dubbo的负载均衡策略&quot;">​</a></h3><h3 id="dubbo的序列化" tabindex="-1">Dubbo的序列化 <a class="header-anchor" href="#dubbo的序列化" aria-label="Permalink to &quot;Dubbo的序列化&quot;">​</a></h3><h2 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;Docker&quot;">​</a></h2><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><h2 id="k8s" tabindex="-1">k8s <a class="header-anchor" href="#k8s" aria-label="Permalink to &quot;k8s&quot;">​</a></h2><h2 id="大数据技术栈" tabindex="-1">大数据技术栈 <a class="header-anchor" href="#大数据技术栈" aria-label="Permalink to &quot;大数据技术栈&quot;">​</a></h2>',261)]))}const E=t(h,[["render",c]]);export{q as __pageData,E as default};
