import{_ as a,c as i,a3 as n,o as l}from"./chunks/framework.Bpx1IrZ-.js";const e="/blog/assets/%E7%BA%BF%E7%A8%8B%E8%BD%AC%E6%8D%A2%E7%8A%B6%E6%80%81%E5%9B%BE.BlhV-Xsn.png",E=JSON.parse('{"title":"02.线程基础","description":"","frontmatter":{"title":"02.线程基础","tags":["java","多线程"],"categories":["java","多线程"]},"headers":[],"relativePath":"java/02.多线程和高并发/02.线程基础.md","filePath":"java/02.多线程和高并发/02.线程基础.md","lastUpdated":1736911123000}'),t={name:"java/02.多线程和高并发/02.线程基础.md"};function p(h,s,r,k,d,c){return l(),i("div",null,s[0]||(s[0]=[n('<h2 id="线程的状态转换" tabindex="-1">线程的状态转换 <a class="header-anchor" href="#线程的状态转换" aria-label="Permalink to &quot;线程的状态转换&quot;">​</a></h2><p><img src="'+e+`" alt="线程转换状态图"></p><table><thead><tr><th style="text-align:center;">线程状态</th><th style="text-align:center;">导致状态发生条件</th></tr></thead><tbody><tr><td style="text-align:center;">NEW(新建)</td><td style="text-align:center;">线程刚被创建，但是并未启动。还没调用start方法。</td></tr><tr><td style="text-align:center;">Runnable(可运行)</td><td style="text-align:center;">线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于<br>操作系统处理器</td></tr><tr><td style="text-align:center;">Blocked(锁阻塞)</td><td style="text-align:center;">当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状<br>态；当该线程持有锁时，该线程将变成Runnable状态。</td></tr><tr><td style="text-align:center;">Waiting(无限等待)</td><td style="text-align:center;">一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个<br>状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒</td></tr><tr><td style="text-align:center;">TimedWaiting(计时等待)</td><td style="text-align:center;">同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。<br>这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep ,<br>Object.wait。</td></tr><tr><td style="text-align:center;">Teminated(被终止)</td><td style="text-align:center;">因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td></tr></tbody></table><h2 id="线程的使用方式" tabindex="-1">线程的使用方式 <a class="header-anchor" href="#线程的使用方式" aria-label="Permalink to &quot;线程的使用方式&quot;">​</a></h2><ol><li>实现Runnable接口</li><li>实现callable接口</li><li>继承Thread类</li></ol><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p><h3 id="实现runnable接口" tabindex="-1">实现runnable接口 <a class="header-anchor" href="#实现runnable接口" aria-label="Permalink to &quot;实现runnable接口&quot;">​</a></h3><p>实现run()方法，通过Thread.start()方法启动线程</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyRunnable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Runnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    MyRunnable instance </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyRunnable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Thread thread </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(instance);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="实现callable接口" tabindex="-1">实现callable接口 <a class="header-anchor" href="#实现callable接口" aria-label="Permalink to &quot;实现callable接口&quot;">​</a></h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyCallable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Callable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Integer </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 123</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] args) throws ExecutionException, InterruptedException {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    MyCallable mc </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyCallable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    FutureTask&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; ft </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> FutureTask&lt;&gt;(mc);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Thread thread </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ft);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ft.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="runnable和callable区别" tabindex="-1">Runnable和Callable区别 <a class="header-anchor" href="#runnable和callable区别" aria-label="Permalink to &quot;Runnable和Callable区别&quot;">​</a></h4><p>Java中的 <code>Runnable</code> 和 <code>Callable</code> 接口都是用于实现多线程的接口，但它们之间存在一些关键的区别：</p><p><strong>返回值</strong></p><ul><li><code>Runnable</code> 接口的 <code>run()</code> 方法没有返回值，它只用于执行一段任务。</li><li><code>Callable</code> 接口的 <code>call()</code> 方法可以返回一个结果，这个结果可以是任意类型。</li></ul><p><strong>异常处理</strong></p><ul><li><code>Runnable</code> 接口的 <code>run()</code> 方法只能抛出运行时异常（unchecked exceptions），且无法捕获处理。</li><li><code>Callable</code> 接口的 <code>call()</code> 方法允许抛出任何类型的异常，包括检查型异常（checked exceptions）和运行时异常。</li></ul><p><strong>使用场景</strong></p><ul><li><code>Runnable</code> 接口通常用于执行那些不需要返回值的任务，例如更新 GUI 界面或进行 I/O 操作。</li><li><code>Callable</code> 接口通常用于执行那些需要返回值的任务，例如计算结果或从数据库中获取数据。</li></ul><p><strong>以下表格总结了 <code>Runnable</code> 和 <code>Callable</code> 接口的主要区别：</strong></p><table><thead><tr><th style="text-align:center;">特性</th><th><code>Runnable</code></th><th><code>Callable</code></th></tr></thead><tbody><tr><td style="text-align:center;">返回值</td><td>无</td><td>有</td></tr><tr><td style="text-align:center;">异常处理</td><td>只能抛出运行时异常</td><td>可以抛出任何类型的异常</td></tr><tr><td style="text-align:center;">使用场景</td><td>不需要返回值的任务</td><td>需要返回值的任务</td></tr></tbody></table><p><strong>此外，<code>Callable</code> 接口还提供了以下优势：</strong></p><ul><li>可以使用 <code>Future</code> 类来获取 <code>call()</code> 方法的返回值。</li><li>可以使用 <code>ExecutorService</code> 类来更轻松地管理多线程。</li></ul><h3 id="继承thread类" tabindex="-1">继承Thread类 <a class="header-anchor" href="#继承thread类" aria-label="Permalink to &quot;继承Thread类&quot;">​</a></h3><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。 当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyThread</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Thread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    MyThread mt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mt.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div>`,30)]))}const b=a(t,[["render",p]]);export{E as __pageData,b as default};
