import{_ as t,c as e,o as r,a3 as s}from"./chunks/framework.DY6izP8J.js";const n="/blog/assets/1742460564183.DcY1zlsh.png",H=JSON.parse('{"title":"13.JUC集合-ConcurrentHashMap","description":"","frontmatter":{"title":"13.JUC集合-ConcurrentHashMap","tags":["java","多线程"],"categories":["java","多线程"]},"headers":[],"relativePath":"java/02.多线程和高并发/13.JUC集合-ConcurrentHashMap.md","filePath":"java/02.多线程和高并发/13.JUC集合-ConcurrentHashMap.md","lastUpdated":1752896647000}'),d={name:"java/02.多线程和高并发/13.JUC集合-ConcurrentHashMap.md"};function o(h,a,c,p,l,i){return r(),e("div",null,a[0]||(a[0]=[s('<h2 id="hashtable为什么慢" tabindex="-1">HashTable为什么慢 <a class="header-anchor" href="#hashtable为什么慢" aria-label="Permalink to &quot;HashTable为什么慢&quot;">​</a></h2><p>Hashtable之所以效率低下主要是因为其实现使用了synchronized关键字对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下。</p><h2 id="concurrenthashmap" tabindex="-1">ConcurrentHashMap <a class="header-anchor" href="#concurrenthashmap" aria-label="Permalink to &quot;ConcurrentHashMap&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">提示</p><p>ConcurrentHashMap 在1.8的版本调整了实现， 本文章主要写1.8版本的ConcurrentHashMap，无特殊说明，相关代码均为1.8版本。</p></div><h3 id="_1-8和1-7的区别" tabindex="-1">1.8和1.7的区别 <a class="header-anchor" href="#_1-8和1-7的区别" aria-label="Permalink to &quot;1.8和1.7的区别&quot;">​</a></h3><table><thead><tr><th>特性</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>数据结构</td><td><code>Segment + HashEntry</code> 分段锁</td><td><code>Node[]</code> 数组 + 红黑树</td></tr><tr><td>并发控制方式</td><td>分段锁</td><td>CAS + Synchronized</td></tr><tr><td>扩容机制</td><td>分段扩容</td><td>并行扩容，效率更高</td></tr><tr><td>红黑树</td><td>❌ 无红黑树</td><td>✅ 链表超阈值转红黑树</td></tr><tr><td>并发性能</td><td>较低</td><td>更高，支持多线程并行扩容</td></tr></tbody></table><h3 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h3><p><img src="'+n+'" alt="ConcurrentHashMap数据结构"> 在结构上，ConcurrentHashMap和HashMap类似，都是由数组+链表+红黑树组成。数组是ConcurrentHashMap的主体，是用来存储元素的。链表和红黑树是为了解决哈希冲突而存在的，链表结构的长度大于8时会转换为红黑树。 只是部分方法为了保证线程安全，使用了synchronized进行加锁或者在方法内部使用CAS操作。</p><div class="danger custom-block"><p class="custom-block-title">注意</p><p>ConcurrentHashMap的初始化，扩容，put，get等操作都是通过CAS或者Synchronized来保证线程安全的。 里面的细节代码和HashMap有很大的不同，但是基本思路都和HashMap相同 可以参考HashMap的源码解析</p><p><a href="./../03.JDK集合源码/02.HashMap源码解析">HashMap源码解析</a></p></div>',9)]))}const C=t(d,[["render",o]]);export{H as __pageData,C as default};
