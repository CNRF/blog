import{_ as l,c as i,o as e,a3 as t}from"./chunks/framework.Dohe277V.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/0000.索引.md","filePath":"algorithm/0000.索引.md","lastUpdated":1744708635000}'),r={name:"algorithm/0000.索引.md"};function o(n,a,h,s,d,c){return e(),i("div",null,a[0]||(a[0]=[t('<h2 id="排序" tabindex="-1">排序 <a class="header-anchor" href="#排序" aria-label="Permalink to &quot;排序&quot;">​</a></h2><h3 id="比较排序" tabindex="-1">比较排序 <a class="header-anchor" href="#比较排序" aria-label="Permalink to &quot;比较排序&quot;">​</a></h3><ol><li><a href="./0001.冒泡排序">冒泡排序</a></li><li><a href="./0002.选择排序">选择排序</a></li><li><a href="./0003.插入排序">插入排序</a></li></ol><h3 id="不基于比较排序" tabindex="-1">不基于比较排序 <a class="header-anchor" href="#不基于比较排序" aria-label="Permalink to &quot;不基于比较排序&quot;">​</a></h3><ol><li>计数排序: (辅助数组，每个元素的值作为索引，统计每个元素出现的次数，然后从小到大依次放入原数组) <ul><li>适合范围小的整数排序</li><li>时间复杂度O(n+k)，空间复杂度O(k)</li><li>适合范围小的整数排序</li></ul></li><li>桶排序: (将数据分到不同的桶中，然后对每个桶进行排序，最后将桶中的数据合并) <ul><li>适合范围小的整数排序</li><li>时间复杂度O(n+k)，空间复杂度O(n)</li></ul></li><li>基数排序((将数据按位分组，从低位到高位进行排序)) <ul><li>适合范围小的整数排序</li><li>时间复杂度O(n*k)，空间复杂度O(n+k)</li></ul></li></ol><h2 id="前缀树" tabindex="-1">前缀树 <a class="header-anchor" href="#前缀树" aria-label="Permalink to &quot;前缀树&quot;">​</a></h2><ol><li>桶排序</li></ol>',7)]))}const f=l(r,[["render",o]]);export{m as __pageData,f as default};
