import{_ as s,c as a,o as i,a5 as n}from"./chunks/framework.BV-pm6eq.js";const l="/blog/assets/java%E4%B8%BB%E6%B5%81%E9%94%81%E6%A6%82%E5%BF%B5.BZBmoy_b.png",t="/blog/assets/java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.-csi-s_1.png",e="/blog/assets/markword%E6%A8%A1%E5%9E%8B.DL0pksi7.png",r="/blog/assets/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.CEWehFvK.png",p="/blog/assets/%E8%87%AA%E6%97%8B%E9%94%81.CCqWWo92.png",h="/blog/assets/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.B4kl7Kvo.png",o="/blog/assets/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8A%A0%E9%94%81%E5%89%8D%E7%8A%B6%E6%80%81.DzIaUqn9.png",d="/blog/assets/%E8%8E%B7%E5%8F%96%E5%88%B0%E8%BD%BB%E9%87%8F%E9%94%81%E7%9A%84%E5%86%85%E5%AD%98%E7%8A%B6%E6%80%81.3zUV4XvN.png",k="/blog/assets/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%86%A8%E8%83%80%E8%BF%87%E7%A8%8B.DXzP2wEG.png",c="/blog/assets/%E5%81%8F%E5%90%91%E9%94%81%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.CxynhArg.png",C=JSON.parse('{"title":"03.java中的锁","description":"","frontmatter":{"title":"03.java中的锁","tags":["java","多线程"],"categories":["java","多线程"]},"headers":[],"relativePath":"java/02.多线程和高并发/03.java中的锁.md","filePath":"java/02.多线程和高并发/03.java中的锁.md","lastUpdated":1724138822000}'),g={name:"java/02.多线程和高并发/03.java中的锁.md"},E=n('<p><img src="'+l+'" alt="java主流锁概念"></p><h2 id="java对象内存模型" tabindex="-1">Java对象内存模型 <a class="header-anchor" href="#java对象内存模型" aria-label="Permalink to &quot;Java对象内存模型&quot;">​</a></h2><p><img src="'+t+'" alt="java中对象内存模型.png"></p><p>一个Java对象由，对象标记，类型指针，真实数据，内存对齐四部分组成。</p><ul><li>对象标记也称Mark Word字段，存储当前对象的一些运行时数据。</li><li>类型指针，JVM根据该指针确定该对象是哪个类的实例化对象。</li><li>真实数据自然是对象的属性值。</li><li>内存补齐，是当数据不是对齐数的整数倍的时候，进行调整，使得对象的整体大小是对齐数的整数倍方便寻址。典型的以空间换时间的思想。</li></ul><p><strong>其中对象标记和类型指针统称为Java对象头。</strong></p><h5 id="mark-word字段" tabindex="-1">Mark Word字段 <a class="header-anchor" href="#mark-word字段" aria-label="Permalink to &quot;Mark Word字段&quot;">​</a></h5><p>Mark Word用于存储对象自身运行时的数据，如hashcode，GC分代年龄，锁状态标志位，线程持有的锁，偏向线程ID，等等。 <img src="'+e+'" alt="mark word模型"></p><h5 id="为社么java的任意对象都可以作为锁" tabindex="-1">为社么Java的任意对象都可以作为锁？ <a class="header-anchor" href="#为社么java的任意对象都可以作为锁" aria-label="Permalink to &quot;为社么Java的任意对象都可以作为锁？&quot;">​</a></h5><p><strong>在Java对象头中，存在一个monitor对象</strong> ，每个对象自创建之后在对象头中就含有monitor对象，monitor是线程私有的，不同的对象monitor自然也是不同的，因此对象作为锁的本质是对象头中的monitor对象作为了锁。这便是为什么Java的任意对象都可以作为锁的原因。</p><blockquote><p>当对象在<strong>无锁的状态下进行了hashcode</strong>的计算（equals方法等）时，无法进入到偏向锁的状态（**因为偏向锁会</p></blockquote><h2 id="乐观锁和悲观锁" tabindex="-1">乐观锁和悲观锁 <a class="header-anchor" href="#乐观锁和悲观锁" aria-label="Permalink to &quot;乐观锁和悲观锁&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">提示</p><p>乐观锁和悲观锁是一种广义上的概念，在java和数据库相关操作中都有体现</p></div><p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据， 因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><ol><li>Java中，<code>synchronized</code>关键字和<code>Lock</code>的实现类都是悲观锁。</li><li>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁， 只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。 如果这个数据没有被更新，当前线程将自己修改的数据成功写入。 如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。 乐观锁在Java中是通过使用无锁编程来实现， 最常采用的是<code>CAS算法</code>，Java原子类中的递增操作就通过CAS自旋实现的。 <img src="'+r+`" alt="乐观锁和悲观锁"></li></ol><p>根据从上面的概念描述我们可以发现：</p><ul><li><strong>悲观锁适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。</li><li><strong>乐观锁适合读操作多的场景</strong>，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ------------------------- 悲观锁的调用方式 -------------------------</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// synchronized</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> synchronized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 操作同步资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ReentrantLock</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReentrantLock lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 需要保证多个线程使用的是同一个锁</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> modifyPublicResources</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 操作同步资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ------------------------- 乐观锁的调用方式 -------------------------</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AtomicInteger atomicInteger </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AtomicInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 需要保证多个线程使用的是同一个AtomicInteger</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">atomicInteger.</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">incrementAndGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//执行自增1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源 乐观锁详见 <a href="./08.JUC原子类，CAS，Unsafe">JUC原子类，CAS，Unsafe</a></p><h2 id="自旋锁" tabindex="-1">自旋锁 <a class="header-anchor" href="#自旋锁" aria-label="Permalink to &quot;自旋锁&quot;">​</a></h2><p><img src="`+p+'" alt="自旋锁"><strong>自旋锁</strong>是一种<strong>忙等待</strong>的同步机制，当一个线程试图获取锁时，它会<strong>不断循环尝试获取锁</strong> ，直到成功为止。如果锁已经被其他线程持有，则当前线程不会进入阻塞状态，而是继续循环等待。</p><h3 id="自旋锁的原理" tabindex="-1">自旋锁的原理 <a class="header-anchor" href="#自旋锁的原理" aria-label="Permalink to &quot;自旋锁的原理&quot;">​</a></h3><p>自旋锁的原理是利用 CPU 的缓存机制来提高效率。当一个线程试图获取锁时，它会首先检查锁的状态。如果锁是空闲的，则当前线程就可以立即获取锁。如果锁已经被其他线程持有，则当前线程会进入一个循环，不断检查锁的状态。由于锁的状态通常存储在 CPU 的缓存中，因此检查锁的状态的开销很小。</p><h3 id="自旋锁的优点" tabindex="-1">自旋锁的优点 <a class="header-anchor" href="#自旋锁的优点" aria-label="Permalink to &quot;自旋锁的优点&quot;">​</a></h3><ul><li><strong>效率高</strong>：自旋锁的效率通常比其他类型的锁更高，因为它们不需要使线程进入阻塞状态。</li><li><strong>可伸缩性好</strong>：自旋锁的可伸缩性好，因为它们不需要使用额外的同步机制，例如等待队列。</li></ul><h3 id="自旋锁的缺点" tabindex="-1">自旋锁的缺点 <a class="header-anchor" href="#自旋锁的缺点" aria-label="Permalink to &quot;自旋锁的缺点&quot;">​</a></h3><ul><li><strong>可能导致 CPU 浪费</strong>：如果锁被竞争得很激烈，则自旋锁可能会导致 CPU 浪费，因为所有等待获取锁的线程都会一直循环检查锁的状态。</li><li><strong>不适用于长等待时间的情况</strong>：如果锁的持有时间很长，则自旋锁可能会降低效率，因为等待的线程会一直占用 CPU 资源。</li></ul><h3 id="自旋锁的应用场景" tabindex="-1">自旋锁的应用场景 <a class="header-anchor" href="#自旋锁的应用场景" aria-label="Permalink to &quot;自旋锁的应用场景&quot;">​</a></h3><p>自旋锁通常用于<strong>竞争不激烈的情况</strong>，例如：</p><ul><li>短小的临界区</li><li>访问频率高的共享资源</li><li>多核 CPU 环境</li></ul><h3 id="java-中的自旋锁实现" tabindex="-1">Java 中的自旋锁实现 <a class="header-anchor" href="#java-中的自旋锁实现" aria-label="Permalink to &quot;Java 中的自旋锁实现&quot;">​</a></h3><p>Java 中的自旋锁可以使用 <code>AbstractQueuedSynchronizer</code> (AQS) 抽象类的 <code>tryAcquire(int acquires)</code> 方法来实现。该方法会尝试获取锁，如果成功则返回 <code>true</code>，否则返回 <code>false</code>。如果锁已经被其他线程持有，则当前线程会<strong>在有限的次数内 <strong>继续尝试获取锁，如果</strong>仍然失败</strong>则会进入阻塞状态。</p><p>以下是一些 Java 中常用的自旋锁实现：</p><ul><li><code>java.util.concurrent.locks.ReentrantLock</code> 类的 <code>tryLock()</code> 方法</li><li><code>java.util.concurrent.atomic.AtomicInteger</code> 类的 <code>compareAndSet()</code> 方法</li><li><code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code> 类的 <code>tryAcquire(int acquires)</code> 方法</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>自旋锁是一种高效的同步机制，但<strong>只适用于竞争不激烈的情况</strong>。在选择使用自旋锁时，应根据具体的应用场景进行权衡。</p><h2 id="公平锁和非公平锁" tabindex="-1">公平锁和非公平锁 <a class="header-anchor" href="#公平锁和非公平锁" aria-label="Permalink to &quot;公平锁和非公平锁&quot;">​</a></h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。 公平锁的优点</p><ol><li>是等待锁的线程不会饿死。</li></ol><p>公平锁的缺点</p><ol><li>是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</li></ol><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。 但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁， 所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销， 整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。 缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p><img src="'+h+`" alt="公平锁和非公平锁"></p><h2 id="可重入锁和非可重入锁" tabindex="-1">可重入锁和非可重入锁 <a class="header-anchor" href="#可重入锁和非可重入锁" aria-label="Permalink to &quot;可重入锁和非可重入锁&quot;">​</a></h2><p><strong>可重入锁</strong>是指同一个线程可以重复获取同一把锁。在 Java 中，<code>synchronized</code> 关键字和 <code>ReentrantLock</code> 类都是可重入锁。</p><p><strong>非可重入锁</strong>是指同一个线程只能获取同一把锁一次。如果线程再次尝试获取已持有的锁，则会发生死锁。Java 中的非可重入锁很少见，通常只在某些特定情况下使用。</p><h3 id="可重入锁的优点" tabindex="-1">可重入锁的优点 <a class="header-anchor" href="#可重入锁的优点" aria-label="Permalink to &quot;可重入锁的优点&quot;">​</a></h3><ul><li><strong>避免死锁</strong>：可重入锁可以防止同一个线程重复获取同一把锁，从而避免死锁。</li><li><strong>提高代码的可读性和可维护性</strong>：可重入锁的使用可以使代码更加清晰易懂，更容易维护。</li></ul><h3 id="非可重入锁的优点" tabindex="-1">非可重入锁的优点 <a class="header-anchor" href="#非可重入锁的优点" aria-label="Permalink to &quot;非可重入锁的优点&quot;">​</a></h3><ul><li><strong>效率更高</strong>：非可重入锁的实现通常比可重入锁更简单，因此效率更高。</li><li><strong>占用更少的内存</strong>：非可重入锁通常需要更少的内存空间来存储锁状态。</li></ul><h3 id="可重入锁和非可重入锁的应用场景" tabindex="-1">可重入锁和非可重入锁的应用场景 <a class="header-anchor" href="#可重入锁和非可重入锁的应用场景" aria-label="Permalink to &quot;可重入锁和非可重入锁的应用场景&quot;">​</a></h3><ul><li><strong>可重入锁</strong>通常用于需要同步访问共享资源的代码块，例如银行账户转账操作。</li><li><strong>非可重入锁</strong>通常用于需要确保代码块只能被一个线程执行的情况，例如创建单例对象。</li></ul><h3 id="如何区分可重入锁和非可重入锁" tabindex="-1">如何区分可重入锁和非可重入锁 <a class="header-anchor" href="#如何区分可重入锁和非可重入锁" aria-label="Permalink to &quot;如何区分可重入锁和非可重入锁&quot;">​</a></h3><p>在 Java 中，区分可重入锁和非可重入锁的最简单方法是查看锁的实现。<code>synchronized</code> 关键字和 <code>ReentrantLock</code> 类是可重入锁，而其他类型的锁可能是非可重入锁。</p><p>以下是一些常见的非可重入锁：</p><ul><li><code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code> 类的某些子类，例如 <code>ReentrantLock</code> 和 <code>Semaphore</code></li><li><code>java.util.concurrent.locks.ReadWriteLock</code> 类的读写锁</li></ul><h3 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>可重入锁和非可重入锁都是 Java 中用于同步多线程访问共享资源的机制。可重入锁可以避免死锁，提高代码的可读性和可维护性，但效率较低并占用更多的内存。非可重入锁效率更高并占用更少的内存，但可能导致死锁。在选择使用哪种类型的锁时，应根据具体的应用场景进行权衡。</p><h2 id="独享锁-排他锁-和共享锁" tabindex="-1">独享锁（排他锁）和共享锁 <a class="header-anchor" href="#独享锁-排他锁-和共享锁" aria-label="Permalink to &quot;独享锁（排他锁）和共享锁&quot;">​</a></h2><p><strong>独享锁（排他锁）<strong>是指</strong>一次只能被一个线程持有的锁</strong>。获得独享锁的线程可以对共享资源进行读写操作。其他线程在当前线程持有独享锁期间不能对共享资源进行任何操作，直到该线程释放独享锁。</p><p><strong>共享锁</strong>是指<strong>允许多个线程同时持有的锁</strong>。获得共享锁的线程只能对共享资源进行读取操作，不能进行修改操作。其他线程可以同时获得共享锁，但不能在已经有线程持有共享锁的情况下获得独享锁。</p><h3 id="独享锁和共享锁的比较" tabindex="-1">独享锁和共享锁的比较 <a class="header-anchor" href="#独享锁和共享锁的比较" aria-label="Permalink to &quot;独享锁和共享锁的比较&quot;">​</a></h3><table><thead><tr><th>特性</th><th>独享锁</th><th>共享锁</th></tr></thead><tbody><tr><td>持有线程数</td><td>一个</td><td>多个</td></tr><tr><td>操作类型</td><td>读写</td><td>只读</td></tr><tr><td>互斥性</td><td>强</td><td>弱</td></tr><tr><td>效率</td><td>较低</td><td>较高</td></tr><tr><td>适用场景</td><td>需要对共享资源进行独占访问的情况</td><td>需要对共享资源进行并发读取的情况</td></tr></tbody></table><h3 id="独享锁和共享锁的实现" tabindex="-1">独享锁和共享锁的实现 <a class="header-anchor" href="#独享锁和共享锁的实现" aria-label="Permalink to &quot;独享锁和共享锁的实现&quot;">​</a></h3><p>Java 中的独享锁和共享锁都是通过 <strong>AbstractQueuedSynchronizer</strong> (AQS) 抽象类来实现的。AQS 提供了一套用于实现同步机制的基本方法，例如 <code>acquire</code>、<code>release</code> 和 <code>tryAcquire</code>。</p><p>独享锁通常是通过 AQS 的 <code>tryAcquire(int acquires)</code> 方法来实现的。该方法会尝试获取锁，如果成功则返回 <code>true</code> ，否则返回 <code>false</code>。如果锁已经被其他线程持有，则当前线程会阻塞，直到该线程释放锁。</p><p>共享锁通常是通过 AQS 的 <code>hasQueuedThread</code> 方法来实现的。该方法会检查是否有其他线程正在等待获取锁，如果<strong>没有</strong> 则当前线程可以获取锁，否则当前线程会加入等待队列。</p><h3 id="独享锁和共享锁的应用场景" tabindex="-1">独享锁和共享锁的应用场景 <a class="header-anchor" href="#独享锁和共享锁的应用场景" aria-label="Permalink to &quot;独享锁和共享锁的应用场景&quot;">​</a></h3><p><strong>独享锁</strong>通常用于需要对共享资源进行<strong>独占访问</strong>的情况，例如：</p><ul><li>银行账户转账操作</li><li>文件读写操作</li><li>数据库更新操作</li></ul><p><strong>共享锁</strong>通常用于需要对共享资源进行<strong>并发读取</strong>的情况，例如：</p><ul><li>缓存数据读取</li><li>商品信息查询</li><li>日志文件读取</li></ul><h3 id="总结-2" tabindex="-1">总结 <a class="header-anchor" href="#总结-2" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>独享锁和共享锁都是 Java 中用于同步多线程访问共享资源的机制。独享锁可以确保共享资源在同一时间只能被一个线程访问，而共享锁可以允许多个线程同时读取共享资源。在选择使用哪种类型的锁时，应根据具体的应用场景进行权衡。</p><h2 id="jvm中锁的优化" tabindex="-1">JVM中锁的优化 <a class="header-anchor" href="#jvm中锁的优化" aria-label="Permalink to &quot;JVM中锁的优化&quot;">​</a></h2><ol><li>锁升级: 优先加轻量级的锁</li><li>自旋锁: 对轻量级锁升级重量级锁时候的一种优化</li><li>锁消除: 对于线程的私有变量，不存在并发问题，没有必要加锁，即使加锁编译后，也会去掉</li><li>锁粗化: 当一个循环中存在加锁操作时，可以将加锁操作提到循环外面执行，一次加锁代替多次加锁，提升性能。</li><li>轻量级锁</li><li>偏向锁: 优先上次获取到锁</li></ol><h3 id="jvm中锁的分类及锁升级机制" tabindex="-1">JVM中锁的分类及锁升级机制 <a class="header-anchor" href="#jvm中锁的分类及锁升级机制" aria-label="Permalink to &quot;JVM中锁的分类及锁升级机制&quot;">​</a></h3><h4 id="偏向锁" tabindex="-1">偏向锁 <a class="header-anchor" href="#偏向锁" aria-label="Permalink to &quot;偏向锁&quot;">​</a></h4><p>偏向锁针对的是锁不存在竞争，每次仅有一个线程来获取该锁，为了提高获取锁的效率，因此将该锁偏向该线程。提升性能。</p><p><strong>偏向锁的获取：</strong></p><blockquote><p>1.首先检测是否为可偏向状态（锁标识是否设置成1，锁标志位是否为01）. 2.如果处于可偏向状态，测试Mark Word中的线程ID是否指向自己，如果是，不需要再次获取锁，直接执行同步代码。 3.如果线程Id，不是自己的线程Id，通过CAS获取锁，获取成功表明当前偏向锁不存在竞争，获取失败，则说明当前偏向锁存在 锁竞争，偏向锁膨胀为轻量级锁。</p></blockquote><p><strong>偏向锁的撤销：</strong></p><p>偏向锁只有当出现竞争时，才会出现锁撤销。</p><blockquote><p>1。等待一个全局安全点，此时所有的线程都是暂停的，检查持有锁的线程状态，如果能找到说明当前线程还存活，说明还在执行同步块中的代码，首先将该线程阻塞，然后进行锁升级，升级到轻量级锁，唤醒该线程继续执行代同步码。</p><p>2.如果持有偏向锁的线程未存活，将对象头中的线程置null，然后直接锁升级。</p></blockquote><h4 id="轻量级锁" tabindex="-1">轻量级锁 <a class="header-anchor" href="#轻量级锁" aria-label="Permalink to &quot;轻量级锁&quot;">​</a></h4><p>偏向锁考虑的是不存在多个线程竞争同一把锁，而轻量级锁考虑的是，多个线程不会在同一时刻来竞争同一把锁。</p><p><strong>轻量级锁的获取：</strong></p><blockquote><p>1.在线程的栈帧中创建用于存储锁记录得空间，</p><p>2.并将Mark Word复制到锁记录中，（这一步不论是否存在竞争都可以执行）。</p><p>3.尝试使用CAS将对象头中得Mark word字段变成指向锁记录得指针。</p><p>4 操作成功，不存在锁竞争，执行同步代码。</p><p>5操作失败，锁已经被其它线程抢占了，这时轻量级锁膨胀为重量级锁。</p></blockquote><p><strong>轻量级锁得释放：</strong></p><blockquote><p>反替换，使用CAS将栈帧中得锁录空间替换到对象头，成功没有锁竞争，锁得以释放，失败说明存在竞争，那块指向锁记录得指针有别的线程在用，因此锁膨胀升级为重量级锁。</p></blockquote><h4 id="重量级锁" tabindex="-1">重量级锁 <a class="header-anchor" href="#重量级锁" aria-label="Permalink to &quot;重量级锁&quot;">​</a></h4><p>重量级锁描述同一时刻有多个线程竞争同一把锁。</p><blockquote><p>当多个线程共同竞争同一把锁时，竞争失败得锁会被阻塞，等到持有锁的线程将锁释放后再次唤醒阻塞的线程，因为线程的唤醒和阻塞是一个很耗费CPU资源的操作，因此此处采取自适应自旋来获取重量级锁来获取重量级锁。</p></blockquote><h4 id="锁的升级" tabindex="-1">锁的升级 <a class="header-anchor" href="#锁的升级" aria-label="Permalink to &quot;锁的升级&quot;">​</a></h4><p><strong>升级过程不可逆</strong></p><blockquote><p>无锁 –-&gt; 偏向锁 ---&gt; 轻量级锁 ---&gt; 重量级锁</p></blockquote><h3 id="自旋锁和自适应自旋锁" tabindex="-1">自旋锁和自适应自旋锁 <a class="header-anchor" href="#自旋锁和自适应自旋锁" aria-label="Permalink to &quot;自旋锁和自适应自旋锁&quot;">​</a></h3><p>自旋锁和自适应自旋锁都是Java中常用的锁机制，用于在多线程环境下控制对共享资源的访问。它们的主要区别在于自旋等待的时间不同。</p><h4 id="自旋锁-1" tabindex="-1">自旋锁 <a class="header-anchor" href="#自旋锁-1" aria-label="Permalink to &quot;自旋锁&quot;">​</a></h4><p>自旋锁是一种乐观锁，它会<strong>不断尝试获取锁</strong>，直到成功为止。如果在自旋等待期间锁被其他线程占用，当前线程会<strong>一直循环</strong> ，继续尝试获取锁。</p><p>自旋锁的优点是效率较高，因为它<strong>不需要像重量级锁那样</strong>进入操作系统内核进行阻塞。但是，自旋锁的缺点是**可能会占用大量的CPU时间 **，尤其是当锁被占用时间较长时。</p><h4 id="自适应自旋锁" tabindex="-1">自适应自旋锁 <a class="header-anchor" href="#自适应自旋锁" aria-label="Permalink to &quot;自适应自旋锁&quot;">​</a></h4><p>自适应自旋锁是一种<strong>更加智能</strong>的自旋锁。它会<strong>根据以往获取锁的成功率来调整自旋等待的时间</strong> 。如果以往获取锁的成功率较高，则自旋等待的时间会更长；如果以往获取锁的成功率较低，则自旋等待的时间会更短，甚至直接放弃自旋等待。</p><p>自适应自旋锁的优点是<strong>兼顾了效率和公平性</strong>。它能够在大多数情况下快速获取锁，同时也能避免在锁被占用时间较长时占用大量的CPU时间。</p><h4 id="比较" tabindex="-1">比较 <a class="header-anchor" href="#比较" aria-label="Permalink to &quot;比较&quot;">​</a></h4><table><thead><tr><th>特性</th><th>自旋锁</th><th>自适应自旋锁</th></tr></thead><tbody><tr><td>自旋等待时间</td><td>固定</td><td>自适应</td></tr><tr><td>优点</td><td>效率高</td><td>兼顾效率和公平性</td></tr><tr><td>缺点</td><td>可能会占用大量的CPU时间</td><td>实现复杂度较高</td></tr></tbody></table><h4 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h4><ul><li><strong>自旋锁</strong>适用于<strong>锁被占用时间较短</strong>的情况，例如获取锁的代码块<strong>执行时间很短</strong>。</li><li><strong>自适应自旋锁</strong>适用于<strong>锁被占用时间不确定</strong>的情况，例如获取锁的代码块<strong>执行时间</strong>可能<strong>很短</strong>，也可能<strong>很长</strong>。</li></ul><h3 id="锁消除" tabindex="-1">锁消除 <a class="header-anchor" href="#锁消除" aria-label="Permalink to &quot;锁消除&quot;">​</a></h3><p>锁消除是Java虚拟机（JVM）在运行时对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除的一种优化手段。</p><h4 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h4><p>锁消除是基于<strong>逃逸分析</strong>技术的。逃逸分析是指分析对象的使用情况，判断对象是否可能逃逸出当前方法或线程的范围。如果一个对象不会逃逸出当前方法或线程的范围，则该对象是线程私有的，对其进行同步操作是没有必要的。</p><p>JVM通过分析代码可以发现一些<strong>不可能存在共享数据竞争</strong>的情况，例如：</p><ul><li>对<strong>final</strong>修饰的变量的读写操作</li><li>对<strong>局部变量</strong>的读写操作</li><li>对<strong>栈上对象</strong>的读写操作</li></ul><p>在这些情况下，JVM会消除相应的同步锁，从而提高程序的性能。</p><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h4><p>锁消除的优点是<strong>提高程序的性能</strong>。通过消除不必要的同步锁，可以减少对CPU资源的占用，提高程序的运行速度。</p><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><p>锁消除的缺点是<strong>具有一定的局限性</strong>。它只能消除一些<strong>特定情况</strong>下的同步锁，并不能完全替代同步锁。</p><h4 id="使用场景-1" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景-1" aria-label="Permalink to &quot;使用场景&quot;">​</a></h4><p>锁消除通常适用于以下场景：</p><ul><li>对<strong>final</strong>修饰的变量进行读写操作</li><li>对<strong>局部变量</strong>进行读写操作</li><li>对<strong>栈上对象</strong>进行读写操作</li></ul><h4 id="举例" tabindex="-1">举例 <a class="header-anchor" href="#举例" aria-label="Permalink to &quot;举例&quot;">​</a></h4><p>以下代码中的同步锁可以被消除：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(num);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在上述代码中，<code>num</code>变量是<strong>final</strong>修饰的，因此它是线程私有的，对其进行同步操作是没有必要的。JVM会消除该同步锁，从而提高程序的性能。</p><h3 id="锁粗化" tabindex="-1">锁粗化 <a class="header-anchor" href="#锁粗化" aria-label="Permalink to &quot;锁粗化&quot;">​</a></h3><p>锁粗化（Lock Coarsening）是一种<strong>将多个细粒度的锁合并成一个粗粒度的锁</strong>的优化技术，它旨在减少锁的加锁和解锁操作的次数，从而提高Java程序的并发性能。</p><h4 id="原理-1" tabindex="-1">原理 <a class="header-anchor" href="#原理-1" aria-label="Permalink to &quot;原理&quot;">​</a></h4><p>锁粗化是基于这样一个假设：<strong>如果一组操作都是对同一个共享资源进行操作，那么将这组操作的锁合并成一个粗粒度的锁，通常会比对每个操作单独加锁要高效</strong>。</p><p>例如，以下代码中的锁可以被粗化为一个粗粒度的锁：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            num1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            num2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述代码中，<code>m()</code>方法对<code>num1</code>和<code>num2</code>两个变量进行了操作。这两个变量都是线程私有的，因此可以将对它们的同步操作合并成一个粗粒度的锁。</p><h4 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h4><p>锁粗化的优点是<strong>提高程序的并发性能</strong>。通过减少锁的加锁和解锁操作的次数，可以减少对CPU资源的占用，提高程序的运行速度。</p><h4 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><p>锁粗化的缺点是<strong>可能会降低某些情况下的同步性</strong>。如果多个线程同时竞争同一个粗粒度的锁，那么这些线程的执行效率会降低。</p><h4 id="使用场景-2" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景-2" aria-label="Permalink to &quot;使用场景&quot;">​</a></h4><p>锁粗化通常适用于以下场景：</p><ul><li>对<strong>同一个共享资源进行多个操作</strong></li><li><strong>多个操作的锁竞争概率较低</strong></li></ul><h4 id="举例-1" tabindex="-1">举例 <a class="header-anchor" href="#举例-1" aria-label="Permalink to &quot;举例&quot;">​</a></h4><p>以下代码中的锁可以被粗化为一个粗粒度的锁：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (list) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(num);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (list) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在上述代码中，<code>add()</code>方法和<code>get()</code>方法都对<code>list</code>变量进行了操作。<code>list</code>变量是一个线程安全的集合，因此可以将对它的同步操作合并成一个粗粒度的锁。</p><h3 id="轻量级锁-1" tabindex="-1">轻量级锁 <a class="header-anchor" href="#轻量级锁-1" aria-label="Permalink to &quot;轻量级锁&quot;">​</a></h3><p>在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(JVM会将对象头中的Mark Word拷贝到锁记录中，官方称为Displaced Mark Ward)这个时候线程堆栈与对象头的状态如图： <img src="`+o+'" alt="轻量级锁加锁前状态"> 如上图所示：如果当前对象没有被锁定，那么锁标志位为01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录Lock Record的空间用于存储锁对象目前的Mark Word的拷贝。​ 然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将Mark Word更新为指向Lock Record的指针。如果更新成功了，那么这个线程就拥用了该对象的锁，并且对象Mark Word的锁标志位更新为(Mark Word中最后的2bit)00，即表示此对象处于轻量级锁定状态，如图：</p><p><img src="'+d+'" alt="获取到轻量锁的内存状态"></p><p>如果这个更新操作失败，JVM会检查当前的<code>Mark Word</code>中是否存在指向当前线程的栈帧的指针， 如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了， 如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀为重量级锁，没有获得锁的线程会被阻塞。 此时，锁的标志位为10.Mark Word中存储的指向重量级锁的指针。轻量级解锁时， 会使用原子的CAS操作将Displaced Mark Word替换回到对象头中，如果成功，则表示没有发生竞争关系。 如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁，导致锁膨胀的流程图如下： <img src="'+k+'" alt="轻量级锁膨胀过程"></p><h3 id="偏向锁-1" tabindex="-1">偏向锁 <a class="header-anchor" href="#偏向锁-1" aria-label="Permalink to &quot;偏向锁&quot;">​</a></h3><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID， 以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。 只需要简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。</p><p><img src="'+c+'" alt="偏向锁内存结构"></p><h4 id="偏向锁的撤销" tabindex="-1">偏向锁的撤销 <a class="header-anchor" href="#偏向锁的撤销" aria-label="Permalink to &quot;偏向锁的撤销&quot;">​</a></h4><p>Java 中的偏向锁撤销指的是一种情况，当一个对象被多个线程竞争访问时，原本已经偏向于某个线程的偏向锁可能会被撤销，从而使锁升级为轻量级锁或重量级锁。这个过程通常发生在存在竞争的情况下，JVM 会观察到偏向锁的竞争，如果竞争的情况比较严重，就会撤销偏向锁。</p><p>偏向锁撤销的目的是为了提高并发性能。因为一旦对象的偏向锁被撤销，就意味着锁的所有权将不再针对特定的线程，而是要进行竞争了。这可以防止某个线程长时间独占锁而导致其他线程等待，从而提高程序的并发性能。</p><p>在 Java 中，偏向锁的撤销通常发生在以下情况下：</p><ol><li>当前持有偏向锁的线程不再活跃，即长时间没有获取锁。</li><li>当前持有偏向锁的线程尝试获取锁失败。</li><li>对象被多个线程竞争访问。</li></ol><p>一旦偏向锁被撤销，JVM 将会将锁状态升级为轻量级锁或重量级锁，具体升级为哪种锁取决于竞争的情况和对象的锁状态。</p><p>总的来说，偏向锁的撤销是 JVM 在高并发情况下的一种优化策略，以提高程序的并发性能。</p>',158),u=[E];function b(m,y,A,q,v,F){return i(),a("div",null,u)}const P=s(g,[["render",b]]);export{C as __pageData,P as default};
