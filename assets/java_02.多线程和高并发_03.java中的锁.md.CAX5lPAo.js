import{_ as a,c as s,o as i,a5 as n}from"./chunks/framework.BV-pm6eq.js";const t="/blog/assets/java%E4%B8%BB%E6%B5%81%E9%94%81%E6%A6%82%E5%BF%B5.BZBmoy_b.png",e="/blog/assets/java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.-csi-s_1.png",l="/blog/assets/markword%E6%A8%A1%E5%9E%8B.DL0pksi7.png",r="/blog/assets/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81.CEWehFvK.png",o="/blog/assets/%E8%87%AA%E6%97%8B%E9%94%81.CCqWWo92.png",h="/blog/assets/%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.B4kl7Kvo.png",y=JSON.parse('{"title":"03.java中的锁","description":"","frontmatter":{"title":"03.java中的锁","tags":["java","多线程"],"categories":["java","多线程"]},"headers":[],"relativePath":"java/02.多线程和高并发/03.java中的锁.md","filePath":"java/02.多线程和高并发/03.java中的锁.md","lastUpdated":1713951333000}'),p={name:"java/02.多线程和高并发/03.java中的锁.md"},d=n('<p><img src="'+t+'" alt="java主流锁概念"></p><h2 id="java对象内存模型" tabindex="-1">Java对象内存模型 <a class="header-anchor" href="#java对象内存模型" aria-label="Permalink to &quot;Java对象内存模型&quot;">​</a></h2><p><img src="'+e+'" alt="java中对象内存模型.png"></p><p>一个Java对象由，对象标记，类型指针，真实数据，内存对齐四部分组成。</p><ul><li>对象标记也称Mark Word字段，存储当前对象的一些运行时数据。</li><li>类型指针，JVM根据该指针确定该对象是哪个类的实例化对象。</li><li>真实数据自然是对象的属性值。</li><li>内存补齐，是当数据不是对齐数的整数倍的时候，进行调整，使得对象的整体大小是对齐数的整数倍方便寻址。典型的以空间换时间的思想。</li></ul><p><strong>其中对象标记和类型指针统称为Java对象头。</strong></p><h5 id="mark-word字段" tabindex="-1">Mark Word字段 <a class="header-anchor" href="#mark-word字段" aria-label="Permalink to &quot;Mark Word字段&quot;">​</a></h5><p>Mark Word用于存储对象自身运行时的数据，如hashcode，GC分代年龄，锁状态标志位，线程持有的锁，偏向线程ID，等等。 <img src="'+l+'" alt="mark word模型"></p><h5 id="为社么java的任意对象都可以作为锁" tabindex="-1">为社么Java的任意对象都可以作为锁？ <a class="header-anchor" href="#为社么java的任意对象都可以作为锁" aria-label="Permalink to &quot;为社么Java的任意对象都可以作为锁？&quot;">​</a></h5><p><strong>在Java对象头中，存在一个monitor对象</strong>，每个对象自创建之后在对象头中就含有monitor对象，monitor是线程私有的，不同的对象monitor自然也是不同的，因此对象作为锁的本质是对象头中的monitor对象作为了锁。这便是为什么Java的任意对象都可以作为锁的原因。</p><blockquote><p>当对象在<strong>无锁的状态下进行了hashcode</strong>的计算（equals方法等）时，无法进入到偏向锁的状态（**因为偏向锁会</p></blockquote><h2 id="乐观锁和悲观锁" tabindex="-1">乐观锁和悲观锁 <a class="header-anchor" href="#乐观锁和悲观锁" aria-label="Permalink to &quot;乐观锁和悲观锁&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">提示</p><p>乐观锁和悲观锁是一种广义上的概念，在java和数据库相关操作中都有体现</p></div><p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据， 因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><ol><li>Java中，<code>synchronized</code>关键字和<code>Lock</code>的实现类都是悲观锁。</li><li>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁， 只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。 如果这个数据没有被更新，当前线程将自己修改的数据成功写入。 如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。 乐观锁在Java中是通过使用无锁编程来实现， 最常采用的是<code>CAS算法</code>，Java原子类中的递增操作就通过CAS自旋实现的。 <img src="'+r+`" alt="乐观锁和悲观锁"></li></ol><p>根据从上面的概念描述我们可以发现：</p><ul><li><strong>悲观锁适合写操作多的场景</strong>，先加锁可以保证写操作时数据正确。</li><li><strong>乐观锁适合读操作多的场景</strong>，不加锁的特点能够使其读操作的性能大幅提升。</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ------------------------- 悲观锁的调用方式 -------------------------</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// synchronized</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> synchronized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> testMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 操作同步资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ReentrantLock</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ReentrantLock lock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReentrantLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 需要保证多个线程使用的是同一个锁</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> modifyPublicResources</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 操作同步资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	lock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ------------------------- 乐观锁的调用方式 -------------------------</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AtomicInteger atomicInteger </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AtomicInteger</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 需要保证多个线程使用的是同一个AtomicInteger</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">atomicInteger.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">incrementAndGet</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//执行自增1</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源 乐观锁详见 <a href="./08.JUC原子类，CAS，Unsafe">JUC原子类，CAS，Unsafe</a></p><h2 id="自旋锁" tabindex="-1">自旋锁 <a class="header-anchor" href="#自旋锁" aria-label="Permalink to &quot;自旋锁&quot;">​</a></h2><p><img src="`+o+'" alt="自旋锁"><strong>自旋锁</strong>是一种<strong>忙等待</strong>的同步机制，当一个线程试图获取锁时，它会<strong>不断循环尝试获取锁</strong>，直到成功为止。如果锁已经被其他线程持有，则当前线程不会进入阻塞状态，而是继续循环等待。</p><h3 id="自旋锁的原理" tabindex="-1">自旋锁的原理 <a class="header-anchor" href="#自旋锁的原理" aria-label="Permalink to &quot;自旋锁的原理&quot;">​</a></h3><p>自旋锁的原理是利用 CPU 的缓存机制来提高效率。当一个线程试图获取锁时，它会首先检查锁的状态。如果锁是空闲的，则当前线程就可以立即获取锁。如果锁已经被其他线程持有，则当前线程会进入一个循环，不断检查锁的状态。由于锁的状态通常存储在 CPU 的缓存中，因此检查锁的状态的开销很小。</p><h3 id="自旋锁的优点" tabindex="-1">自旋锁的优点 <a class="header-anchor" href="#自旋锁的优点" aria-label="Permalink to &quot;自旋锁的优点&quot;">​</a></h3><ul><li><strong>效率高</strong>：自旋锁的效率通常比其他类型的锁更高，因为它们不需要使线程进入阻塞状态。</li><li><strong>可伸缩性好</strong>：自旋锁的可伸缩性好，因为它们不需要使用额外的同步机制，例如等待队列。</li></ul><h3 id="自旋锁的缺点" tabindex="-1">自旋锁的缺点 <a class="header-anchor" href="#自旋锁的缺点" aria-label="Permalink to &quot;自旋锁的缺点&quot;">​</a></h3><ul><li><strong>可能导致 CPU 浪费</strong>：如果锁被竞争得很激烈，则自旋锁可能会导致 CPU 浪费，因为所有等待获取锁的线程都会一直循环检查锁的状态。</li><li><strong>不适用于长等待时间的情况</strong>：如果锁的持有时间很长，则自旋锁可能会降低效率，因为等待的线程会一直占用 CPU 资源。</li></ul><h3 id="自旋锁的应用场景" tabindex="-1">自旋锁的应用场景 <a class="header-anchor" href="#自旋锁的应用场景" aria-label="Permalink to &quot;自旋锁的应用场景&quot;">​</a></h3><p>自旋锁通常用于<strong>竞争不激烈的情况</strong>，例如：</p><ul><li>短小的临界区</li><li>访问频率高的共享资源</li><li>多核 CPU 环境</li></ul><h3 id="java-中的自旋锁实现" tabindex="-1">Java 中的自旋锁实现 <a class="header-anchor" href="#java-中的自旋锁实现" aria-label="Permalink to &quot;Java 中的自旋锁实现&quot;">​</a></h3><p>Java 中的自旋锁可以使用 <code>AbstractQueuedSynchronizer</code> (AQS) 抽象类的 <code>tryAcquire(int acquires)</code> 方法来实现。该方法会尝试获取锁，如果成功则返回 <code>true</code>，否则返回 <code>false</code>。如果锁已经被其他线程持有，则当前线程会<strong>在有限的次数内</strong>继续尝试获取锁，如果<strong>仍然失败</strong>则会进入阻塞状态。</p><p>以下是一些 Java 中常用的自旋锁实现：</p><ul><li><code>java.util.concurrent.locks.ReentrantLock</code> 类的 <code>tryLock()</code> 方法</li><li><code>java.util.concurrent.atomic.AtomicInteger</code> 类的 <code>compareAndSet()</code> 方法</li><li><code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code> 类的 <code>tryAcquire(int acquires)</code> 方法</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>自旋锁是一种高效的同步机制，但<strong>只适用于竞争不激烈的情况</strong>。在选择使用自旋锁时，应根据具体的应用场景进行权衡。</p><h2 id="公平锁和非公平锁" tabindex="-1">公平锁和非公平锁 <a class="header-anchor" href="#公平锁和非公平锁" aria-label="Permalink to &quot;公平锁和非公平锁&quot;">​</a></h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。 公平锁的优点</p><ol><li>是等待锁的线程不会饿死。</li></ol><p>公平锁的缺点</p><ol><li>是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</li></ol><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。 但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁， 所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销， 整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。 缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p><img src="'+h+'" alt="公平锁和非公平锁"></p><h2 id="可重入锁和非可重入锁" tabindex="-1">可重入锁和非可重入锁 <a class="header-anchor" href="#可重入锁和非可重入锁" aria-label="Permalink to &quot;可重入锁和非可重入锁&quot;">​</a></h2><p><strong>可重入锁</strong>是指同一个线程可以重复获取同一把锁。在 Java 中，<code>synchronized</code> 关键字和 <code>ReentrantLock</code> 类都是可重入锁。</p><p><strong>非可重入锁</strong>是指同一个线程只能获取同一把锁一次。如果线程再次尝试获取已持有的锁，则会发生死锁。Java 中的非可重入锁很少见，通常只在某些特定情况下使用。</p><h3 id="可重入锁的优点" tabindex="-1">可重入锁的优点 <a class="header-anchor" href="#可重入锁的优点" aria-label="Permalink to &quot;可重入锁的优点&quot;">​</a></h3><ul><li><strong>避免死锁</strong>：可重入锁可以防止同一个线程重复获取同一把锁，从而避免死锁。</li><li><strong>提高代码的可读性和可维护性</strong>：可重入锁的使用可以使代码更加清晰易懂，更容易维护。</li></ul><h3 id="非可重入锁的优点" tabindex="-1">非可重入锁的优点 <a class="header-anchor" href="#非可重入锁的优点" aria-label="Permalink to &quot;非可重入锁的优点&quot;">​</a></h3><ul><li><strong>效率更高</strong>：非可重入锁的实现通常比可重入锁更简单，因此效率更高。</li><li><strong>占用更少的内存</strong>：非可重入锁通常需要更少的内存空间来存储锁状态。</li></ul><h3 id="可重入锁和非可重入锁的应用场景" tabindex="-1">可重入锁和非可重入锁的应用场景 <a class="header-anchor" href="#可重入锁和非可重入锁的应用场景" aria-label="Permalink to &quot;可重入锁和非可重入锁的应用场景&quot;">​</a></h3><ul><li><strong>可重入锁</strong>通常用于需要同步访问共享资源的代码块，例如银行账户转账操作。</li><li><strong>非可重入锁</strong>通常用于需要确保代码块只能被一个线程执行的情况，例如创建单例对象。</li></ul><h3 id="如何区分可重入锁和非可重入锁" tabindex="-1">如何区分可重入锁和非可重入锁 <a class="header-anchor" href="#如何区分可重入锁和非可重入锁" aria-label="Permalink to &quot;如何区分可重入锁和非可重入锁&quot;">​</a></h3><p>在 Java 中，区分可重入锁和非可重入锁的最简单方法是查看锁的实现。<code>synchronized</code> 关键字和 <code>ReentrantLock</code> 类是可重入锁，而其他类型的锁可能是非可重入锁。</p><p>以下是一些常见的非可重入锁：</p><ul><li><code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code> 类的某些子类，例如 <code>ReentrantLock</code> 和 <code>Semaphore</code></li><li><code>java.util.concurrent.locks.ReadWriteLock</code> 类的读写锁</li></ul><h3 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>可重入锁和非可重入锁都是 Java 中用于同步多线程访问共享资源的机制。可重入锁可以避免死锁，提高代码的可读性和可维护性，但效率较低并占用更多的内存。非可重入锁效率更高并占用更少的内存，但可能导致死锁。在选择使用哪种类型的锁时，应根据具体的应用场景进行权衡。</p><h2 id="独享锁-排他锁-和共享锁" tabindex="-1">独享锁（排他锁）和共享锁 <a class="header-anchor" href="#独享锁-排他锁-和共享锁" aria-label="Permalink to &quot;独享锁（排他锁）和共享锁&quot;">​</a></h2><p><strong>独享锁（排他锁）<strong>是指</strong>一次只能被一个线程持有的锁</strong>。获得独享锁的线程可以对共享资源进行读写操作。其他线程在当前线程持有独享锁期间不能对共享资源进行任何操作，直到该线程释放独享锁。</p><p><strong>共享锁</strong>是指<strong>允许多个线程同时持有的锁</strong>。获得共享锁的线程只能对共享资源进行读取操作，不能进行修改操作。其他线程可以同时获得共享锁，但不能在已经有线程持有共享锁的情况下获得独享锁。</p><h3 id="独享锁和共享锁的比较" tabindex="-1">独享锁和共享锁的比较 <a class="header-anchor" href="#独享锁和共享锁的比较" aria-label="Permalink to &quot;独享锁和共享锁的比较&quot;">​</a></h3><table><thead><tr><th>特性</th><th>独享锁</th><th>共享锁</th></tr></thead><tbody><tr><td>持有线程数</td><td>一个</td><td>多个</td></tr><tr><td>操作类型</td><td>读写</td><td>只读</td></tr><tr><td>互斥性</td><td>强</td><td>弱</td></tr><tr><td>效率</td><td>较低</td><td>较高</td></tr><tr><td>适用场景</td><td>需要对共享资源进行独占访问的情况</td><td>需要对共享资源进行并发读取的情况</td></tr></tbody></table><h3 id="独享锁和共享锁的实现" tabindex="-1">独享锁和共享锁的实现 <a class="header-anchor" href="#独享锁和共享锁的实现" aria-label="Permalink to &quot;独享锁和共享锁的实现&quot;">​</a></h3><p>Java 中的独享锁和共享锁都是通过 <strong>AbstractQueuedSynchronizer</strong> (AQS) 抽象类来实现的。AQS 提供了一套用于实现同步机制的基本方法，例如 <code>acquire</code>、<code>release</code> 和 <code>tryAcquire</code>。</p><p>独享锁通常是通过 AQS 的 <code>tryAcquire(int acquires)</code> 方法来实现的。该方法会尝试获取锁，如果成功则返回 <code>true</code>，否则返回 <code>false</code>。如果锁已经被其他线程持有，则当前线程会阻塞，直到该线程释放锁。</p><p>共享锁通常是通过 AQS 的 <code>hasQueuedThread</code> 方法来实现的。该方法会检查是否有其他线程正在等待获取锁，如果<strong>没有</strong>则当前线程可以获取锁，否则当前线程会加入等待队列。</p><h3 id="独享锁和共享锁的应用场景" tabindex="-1">独享锁和共享锁的应用场景 <a class="header-anchor" href="#独享锁和共享锁的应用场景" aria-label="Permalink to &quot;独享锁和共享锁的应用场景&quot;">​</a></h3><p><strong>独享锁</strong>通常用于需要对共享资源进行<strong>独占访问</strong>的情况，例如：</p><ul><li>银行账户转账操作</li><li>文件读写操作</li><li>数据库更新操作</li></ul><p><strong>共享锁</strong>通常用于需要对共享资源进行<strong>并发读取</strong>的情况，例如：</p><ul><li>缓存数据读取</li><li>商品信息查询</li><li>日志文件读取</li></ul><h3 id="总结-2" tabindex="-1">总结 <a class="header-anchor" href="#总结-2" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>独享锁和共享锁都是 Java 中用于同步多线程访问共享资源的机制。独享锁可以确保共享资源在同一时间只能被一个线程访问，而共享锁可以允许多个线程同时读取共享资源。在选择使用哪种类型的锁时，应根据具体的应用场景进行权衡。</p>',74),c=[d];function k(g,u,b,E,m,A){return i(),s("div",null,c)}const q=a(p,[["render",k]]);export{y as __pageData,q as default};
