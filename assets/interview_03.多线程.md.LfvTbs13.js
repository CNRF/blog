import{_ as d,c as e,o,a3 as r}from"./chunks/framework.DY6izP8J.js";const a="/blog/assets/%E7%BA%BF%E7%A8%8B%E8%BD%AC%E6%8D%A2%E7%8A%B6%E6%80%81%E5%9B%BE.BlhV-Xsn.png",c="/blog/assets/markword%E6%A8%A1%E5%9E%8B.DL0pksi7.png",u=JSON.parse('{"title":"03.多线程","description":"","frontmatter":{"title":"03.多线程","tags":[""],"categories":[""]},"headers":[],"relativePath":"interview/03.多线程.md","filePath":"interview/03.多线程.md","lastUpdated":1751421719000}'),i={name:"interview/03.多线程.md"};function n(l,t,s,h,g,p){return o(),e("div",null,t[0]||(t[0]=[r('<h2 id="线程状态变迁" tabindex="-1">线程状态变迁 <a class="header-anchor" href="#线程状态变迁" aria-label="Permalink to &quot;线程状态变迁&quot;">​</a></h2><p><img src="'+a+'" alt="线程状态变更"></p><h2 id="sleep和wait的区别" tabindex="-1">sleep和wait的区别 <a class="header-anchor" href="#sleep和wait的区别" aria-label="Permalink to &quot;sleep和wait的区别&quot;">​</a></h2><table><thead><tr><th>特性</th><th><code>sleep()</code></th><th><code>wait()</code></th></tr></thead><tbody><tr><td>所属类</td><td><code>Thread</code> 类</td><td><code>Object</code> 类</td></tr><tr><td>是否需要 <code>synchronized</code></td><td>不需要</td><td>必须在 <code>synchronized</code> 代码块或方法中使用</td></tr><tr><td>是否释放锁</td><td><strong>不释放</strong>当前对象锁</td><td><strong>释放</strong>当前对象锁</td></tr><tr><td>唤醒方式</td><td>时间到自动唤醒</td><td>需要其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code></td></tr><tr><td>用途</td><td>用于线程睡眠/暂停</td><td>用于线程间通信/协调</td></tr><tr><td>是否可以中断</td><td>可以用 <code>interrupt()</code> 中断</td><td>可以用 <code>interrupt()</code> 中断（会抛出异常）</td></tr><tr><td>作用对象</td><td>当前线程</td><td>任意对象的监视器（锁）</td></tr></tbody></table><h2 id="线程锁升级过程" tabindex="-1">线程锁升级过程 <a class="header-anchor" href="#线程锁升级过程" aria-label="Permalink to &quot;线程锁升级过程&quot;">​</a></h2><blockquote><p>无锁&gt;&gt;偏向锁&gt;&gt;轻量级锁&gt;&gt;重量级锁</p></blockquote><p><img src="'+c+'" alt="锁升级"></p><h2 id="synchronized和lock的区别" tabindex="-1">synchronized和Lock的区别 <a class="header-anchor" href="#synchronized和lock的区别" aria-label="Permalink to &quot;synchronized和Lock的区别&quot;">​</a></h2><table><thead><tr><th>功能点</th><th><code>synchronized</code></th><th><code>Lock</code>（如 ReentrantLock）</th></tr></thead><tbody><tr><td><strong>可中断锁</strong></td><td>不可中断</td><td><code>lockInterruptibly()</code> 可响应中断</td></tr><tr><td><strong>尝试锁</strong></td><td>不支持</td><td><code>tryLock()</code> 可尝试获取锁</td></tr><tr><td><strong>公平锁</strong></td><td>非公平</td><td>可设置为公平锁,具体为方法实现</td></tr><tr><td><strong>读写锁</strong></td><td>不支持</td><td><code>ReadWriteLock</code> 支持读写分离</td></tr><tr><td><strong>重入性</strong></td><td>支持（自动）</td><td>支持（如 <code>ReentrantLock</code>）</td></tr><tr><td><strong>超时锁</strong></td><td>不支持</td><td><code>tryLock(timeout)</code> 支持设置超时时间</td></tr><tr><td><strong>条件变量</strong></td><td>使用 <code>Object.wait/notify</code></td><td>使用 <code>Condition.await/signal</code> 更强大</td></tr><tr><td><strong>自动释放</strong></td><td>自动释放（方法/代码块结束）</td><td>必须手动释放，易出错</td></tr></tbody></table><h2 id="线程池的7大参数" tabindex="-1">线程池的7大参数 <a class="header-anchor" href="#线程池的7大参数" aria-label="Permalink to &quot;线程池的7大参数&quot;">​</a></h2><ol><li>corePoolSize：核心线程数，线程池中始终保持的线程数量。</li><li>maximumPoolSize：最大线程数，线程池允许的最大线程数量。</li><li>keepAliveTime：非核心线程的存活时间，当线程数超过核心线程数时，多余的线程在空闲时会被销毁。</li><li>unit：keepAliveTime的时间单位。</li><li>workQueue：任务队列，用于存放等待执行的任务。</li><li>threadFactory：线程工厂，用于创建新线程。</li><li>handler：拒绝策略，当线程池和队列都满了时，如何处理新提交的任务。</li></ol><h3 id="拒绝策略" tabindex="-1">拒绝策略 <a class="header-anchor" href="#拒绝策略" aria-label="Permalink to &quot;拒绝策略&quot;">​</a></h3><table><thead><tr><th>策略类</th><th>名称</th><th>行为描述</th></tr></thead><tbody><tr><td><code>AbortPolicy</code>（默认）</td><td>中止策略</td><td>直接抛出 <code>RejectedExecutionException</code> 异常</td></tr><tr><td><code>CallerRunsPolicy</code></td><td>调用者运行策略</td><td>由提交任务的线程（一般是主线程）执行该任务</td></tr><tr><td><code>DiscardPolicy</code></td><td>丢弃策略</td><td>直接丢弃任务，不抛异常，不执行</td></tr><tr><td><code>DiscardOldestPolicy</code></td><td>丢弃最旧任务策略</td><td>丢弃队列中最老的任务，然后重新尝试提交当前任务</td></tr></tbody></table>',13)]))}const k=d(i,[["render",n]]);export{u as __pageData,k as default};
