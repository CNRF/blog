---
title: '0016.队列实现栈'
tags: [ '' ]
categories: [ '' ]
---

## 题目介绍

队列实现栈是使用两个队列来模拟栈的后进先出（LIFO）特性。通过将元素从一个队列转移到另一个队列来实现栈的入栈和出栈操作。

## 实现思路

1. 使用两个队列：`queue` 用于入栈操作，`help` 用于辅助出栈操作。
2. 入栈时，将元素直接添加到 `queue` 中。
3. 出栈时，将 `queue` 中的元素逐个移到 `help` 中，直到 `queue` 中只剩下一个元素。这个元素就是要出栈的元素。然后交换 `queue`
   和 `help` 的引用，使得 `queue` 始终指向最新的栈状态。
4. 查看栈顶元素时，同样需要将 `queue` 中的元素逐个移到 `help` 中，直到只剩下一个元素。这个元素是栈顶元素，然后将其放回
   `help` 中，最后交换 `queue` 和 `help` 的引用。

## 实现代码

```java
package lesson.stackandqueue;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Stack;

/**
 * 两个队列实现栈
 *
 * @author mark
 *
 */


public class TwoQueueImplementStack<T> {
    private Queue<T> queue;
    private Queue<T> help;

    public TwoQueueImplementStack() {
        queue = new LinkedList<>();
        help = new LinkedList<>();
    }

    public void push(T value) {
        queue.offer(value);
    }

    public T poll() {
        while (queue.size() > 1) {
            help.offer(queue.poll());
        }
        T ans = queue.poll();
        // 交换 queue 和 help 的引用，而不是创建新的 LinkedList
        Queue<T> temp = queue;
        queue = help;
        help = temp;
        return ans;
    }

    public T peek() {
        while (queue.size() > 1) {
            help.offer(queue.poll());
        }
        T ans = queue.poll();
        help.offer(ans);
        //  help = new LinkedList<>();
        // 交换 queue 和 help 的引用，而不是创建新的 LinkedList
        Queue<T> temp = queue;
        queue = help;
        help = temp;
        return ans;

    }

    public boolean isEmpty() {
        return queue.isEmpty();
    }

    //for test
    public static void main(String[] args) {
        System.out.println("test begin");
        TwoQueueImplementStack<Integer> myStack = new TwoQueueImplementStack<>();
        Stack<Integer> test = new Stack<>();
        int testTime = 1000000;
        int max = 1000000;
        for (int i = 0; i < testTime; i++) {
            if (myStack.isEmpty()) {
                if (!test.isEmpty()) {
                    System.out.println("Oops");
                }
                int num = (int) (Math.random() * max);
                myStack.push(num);
                test.push(num);
            } else {
                if (Math.random() < 0.25) {
                    int num = (int) (Math.random() * max);
                    myStack.push(num);
                    test.push(num);
                } else if (Math.random() < 0.5) {
                    if (!myStack.peek().equals(test.peek())) {
                        System.out.println("Oops");
                    }
                } else if (Math.random() < 0.75) {
                    if (!myStack.poll().equals(test.pop())) {
                        System.out.println("Oops");
                    }
                } else {
                    if (myStack.isEmpty() != test.isEmpty()) {
                        System.out.println("Oops");
                    }
                }
            }
        }

        System.out.println("test finish!");

    }
}

```