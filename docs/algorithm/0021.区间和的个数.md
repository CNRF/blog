---
title: '0021.区间和的个数'
tags: [ '' ]
categories: [ '' ]
---

## 题目

[区间和的个数](https://leetcode.cn/problems/count-of-range-sum/description/)

给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的
区间和的个数 。

区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。

### 例子

输入：nums = [-2,5,-1], lower = -2, upper = 2
输出：3
解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。

## 思路

1. 计算数组的前缀和,将区间问题转化为前缀和问题。sum[i]=nums[0]+nums[1]+...+nums[i]则区间和 S[i, j] = sum[j] - sum[i]。
   此时就转换成在sum数组中找到满足 lower <= sum[j] - sum[i] <= upper 的 i 和 j 的个数。
   其中 sum[i] 表示前 i 个元素的和，sum[j] 表示前 j 个元素的和。
2. 使用归并排序的思想，分治法将数组分成两半，递归地计算左半部分和右半部分的区间和个数，然后合并两部分的结果。
3. 在合并过程中，使用双指针来统计满足条件的区间和个数。
   具体地，对于每个 sum[j]，我们需要找到满足条件的 sum[i-1] 的范围，即 sum[j] - upper <= sum[i-1] <= sum[j] - lower。
   使用两个指针 windowL 和 windowR 来维护这个范围，遍历右半部分的前缀和数组 sum[j]，对于每个 sum[j]，
   我们移动 windowR 指针，直到 sum[windowR] > sum[j] - lower，然后移动 windowL 指针，直到 sum[windowL] >= sum[j] - upper。

## 实现

### merge方法解析

1. `merge` 方法的作用是合并两个已经排序的子数组，并统计满足条件的区间和个数。
2. `windowL` 和 `windowR` 分别表示满足条件的前缀和的左边界和右边界。
3. 对于每个 `sum[i]`，此时i都是在右边数组中，我们需要在左边数组中找到满足条件的 `sum[j]` 的范围，即
   `sum[i] - upper <= sum[j] <= sum[i] - lower`。
4. 在合并过程中，我们使用双指针来维护这个范围，统计满足条件的区间和个数。
5. 最后，将合并后的结果存储到 `help` 数组中，并将其复制回原数组 `sum` 中。
6. 返回满足条件的区间和个数。

> 排序不会影响计算windowL和windowR的个数，因为每次都计算了右边的数的前缀和在取值范围中，
> 所以此时对数据进行调整排序不会影响到最终数据。
> 如 [3,8,5],[9]中只有3，5满足条件，调整成[3,5,8]后还是3,5满足条件（3还是表示[0,0]数组区间数据和，5还是[0,2]区间的数据和）。

### 代码

```java
package lesson.sort;

/**
 * <a href="https://leetcode.cn/problems/count-of-range-sum/description/">...</a>
 *
 * @author mark
 *
 */


public class CountRangeSum {
    public static int countRangeSum(int[] arr, int lower, int upper) {
        if (null == arr || arr.length == 0) {
            return 0;
        }
        Long[] sum = new Long[arr.length];
        sum[0] = (long) arr[0];
        for (int i = 1; i < arr.length; i++) {
            sum[i] = sum[i - 1] + arr[i];
        }
        return process(sum, 0, sum.length - 1, lower, upper);
    }

    public static int process(Long[] sum, int start, int end, int lower, int upper) {
        if (start == end) {
            return (sum[start] >= lower && sum[end] <= upper) ? 1 : 0;
        }
        int mid = start + ((end - start) >> 1);
        return process(sum, start, mid, lower, upper)
                + process(sum, mid + 1, end, lower, upper)
                + merge(sum, start, mid, end, lower, upper);
    }

    private static int merge(Long[] sum, int start, int mid, int end, int lower, int upper) {
        int ans = 0;
        int windowL = start;
        int windowR = start;
        // [windowL, windowR)
        for (int i = mid + 1; i <= end; i++) {

            long min = sum[i] - upper;
            long max = sum[i] - lower;
            // 让windowR停在第一个不满足<=max的位置
            while (windowR <= mid && sum[windowR] <= max) {
                windowR++;
            }
            // 让windowL停在第一个不满足<min的位置
            while (windowL <= mid && sum[windowL] < min) {
                windowL++;
            }
            ans = ans + (windowR - windowL);
        }
        Long[] help = new Long[end - start + 1];
        int i = 0;
        int helpL = start;
        int helpR = mid + 1;
        while (helpL <= mid && helpR <= end) {
            help[i++] = sum[helpL] <= sum[helpR] ? sum[helpL++] : sum[helpR++];
        }
        while (helpL <= mid) {
            help[i++] = sum[helpL++];
        }
        while (helpR <= end) {
            help[i++] = sum[helpR++];
        }
        //此时每次都计算了右边的数的前缀和在取值范围中
        // 所以此时对数据进行调整排序不会影响的到最终数据
        //如 [3,8，5],[9]中只有3，5满足条件，调整成[3,5,8]后还是3,5满足条件
        for (int j = 0; j < help.length; j++) {
            sum[start + j] = help[j];
        }
        return ans;
    }

    public static void main(String[] args) {
        int[] arr = {2147483647, -2147483648, -1, 0};
        int i = countRangeSum(arr, -1, 0);
        System.out.println(i);
    }

}

```