## &（与运算）有零为零

运算规则<font color=red>在二进制中</font>：0&0=0，0&1=0，1&0=0，1&1=1

**即：两位同时为“1”，结果才为“1”，否则为0**

例如：3&5 即 0000 0011& 0000 0101 = 00000001 因此，3&5的值得1。

**另，负数按补码形式参加按位与运算。**

### “与运算”的特殊用途：

1. 清零。如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。
2. 取一个数中指定位（取xx位到xx位的数据）

方法：找一个数，对应X要取的位，该数的对应位为1，其余位为零，此数与X进行“与运算”可以得到X中的指定位。

例：设X=10101110，

取X的低4位，用 X & 0000 1111 = 00001110 即可得到；

还可用来取X的2、4、6位。

## |（或运算）有一为一

按位或运算符（|）

参加运算的两个对象，按二进制位进行“或”运算。

运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1；

即 ：参加运算的两个对象只要有一个为1，其值为1。

例如:3|5 即 00000011 | 0000 0101 = 00000111 因此，3|5的值得7。

**另，负数按补码形式参加按位或运算。**

### “或运算”特殊作用：

（1）常用来对一个数据的**某些位 置1**。

方法：找到一个数，对应X要置1的位，该数的对应位为1，其余位为零。此数与X相或可使X中的某些位置1。

例：将X=10100000的低4位置1 ，用X | 0000 1111 = 1010 1111即可得到。

## ^（异或运算）相同为零

异或运算符（^）

参加运算的两个数据，按二进制位进行“异或”运算。

运算规则：0^0=0； 0^1=1； 1^0=1； 1^1=0；

即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。

### “异或运算”的特殊作用：

（1）使特定位翻转找一个数，对应X要翻转的各位，该数的对应位为1，其余位为零，此数与X对应位异或即可。

例：X=1010 1110，使X低4位翻转，用X ^0000 1111 = 1010 0001即可得到。

（2）与0相异或，保留原值 ，X ^ 00000000 = 1010 1110。

（3）两个数交换 a = a ^ b; b = b ^ a; a= a ^ b

a = 1001, b = 0101 ;

a = a ^ b = 1001^ 0101 = 1100

b = b ^ a = 0101^ 1100 = 1001

a = a ^ b = 1100 ^ 1001 = 0101

## ~(取反运算) 1变0

取反运算符（~）

参加运算的一个数据，按二进制位进行“取反”运算。

运算规则：~1=0； ~0=1；

即：对一个二进制数按位取反，即将0变1，1变0。

### 取反的特殊作用：

（1）使一个数的最低位为零，可以表示为：a&~1。

~1的值为1111111111111110，再按“与”运算，最低位一定为0。

因为“~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。

## 左移运算符（<<）乘以2的次方

将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。

例：a = a<< 2将a的二进制位左移2位，右补0，

左移1位后a = a *2;

若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。

## 右移运算符（>>）除以2的次方

将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。

操作数每右移一位，相当于该数除以2。

例如：a = a>> 2 将a的二进制位右移2位，

<font color=red>左补0 or 补1得看被移数是正还是负。</font>

`>>`运算符把expression1 的所有位向右移 expression2指定的位数。expression1的符号位被用来填充右移后左边空出来的位。向右移出的位被丢弃。

例如，下面的代码被求值后，temp 的值是 -4：

-14 （即二进制的 11110010）右移两位等于 -4（即二进制的 11111100）。

var temp = -14 >> 2

## 负数的二进制

在 Java（以及大多数现代计算机系统）中，负数是以 **补码 (Two's Complement)** 的形式表示和计算二进制的。理解补码是理解负数二进制表示的关键。

计算一个负数的二进制表示通常需要以下步骤：

**1. 获取该负数的绝对值的二进制表示。**

假设我们要计算 -5 的二进制表示（以 8 位为例）：

* 首先，获取 5 的二进制表示：`00000101`

**2. 对绝对值的二进制表示进行按位取反（得到反码或一的补码）。**

将 5 的二进制表示 `00000101` 的每一位取反（0 变为 1，1 变为 0）：

* 反码：`11111010`

**3. 将反码加 1，得到补码。**

将上一步得到的反码 `11111010` 加 1：

* `11111010 + 1 = 11111011`

因此，-5 在 8 位二进制补码中的表示就是 `11111011`。

**Java 中的实现和特性：**

* **符号位:** 在补码表示中，最高位（最左边的位）被用作符号位。
    * 如果最高位是 `0`，则该数是正数或零。
    * 如果最高位是 `1`，则该数是负数。

* **补码的优势:**
    * **简化加法和减法:** 使用补码，加法和减法运算可以使用相同的硬件电路来处理，包括正数和负数。例如，计算 `5 + (-5)`
      在二进制补码中就相当于 `00000101 + 11111011 = 100000000`。溢出的一位被丢弃，结果为 `00000000`，即 0。
    * **唯一的零表示:** 补码表示中只有一个零 (`00000000`)，避免了原码和反码中存在的 `+0` 和 `-0` 的问题。
