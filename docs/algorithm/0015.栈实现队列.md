---
title: '0015.栈实现队列'
tags: [ '' ]
categories: [ '' ]
---

## 算法介绍

栈实现队列是使用两个栈来模拟队列的先进先出（FIFO）特性。通过将元素从一个栈转移到另一个栈来实现队列的入队和出队操作。

## 实现思路

1. 使用两个栈：`stackPush` 用于入队操作，`stackPop` 用于出队操作。
2. 入队时，将元素压入 `stackPush`。
3. 出队时，如果 `stackPop` 为空，则将 `stackPush` 中的所有元素倒入 `stackPop`，然后从 `stackPop` 中弹出元素。
4. 查看队首元素时，同样需要确保 `stackPop` 中有元素，如果没有，则将 `stackPush` 中的元素倒入 `stackPop`，然后返回 `stackPop`
   的栈顶元素。
5. 通过这种方式，确保了队列的先进先出特性。

## 实现代码

```java
package lesson.stackandqueue;

import java.util.Stack;

/**
 * 双栈实现队列
 *
 * @author mark
 *
 */

public class TwoStackImplementQueue {
    private Stack<Integer> stackPush;
    private Stack<Integer> stackPop;

    public TwoStackImplementQueue() {
        stackPush = new Stack<>();
        stackPop = new Stack<>();
    }

    /**
     * push栈的数据倒入到pop栈
     * push：1,3,5
     * pop: 5,3,1
     */
    private void pushToPop() {
        if (stackPop.empty()) {
            while (!stackPush.empty()) {
                stackPop.push(stackPush.pop());
            }
        }
    }

    public void add(int value) {
        stackPush.push(value);
        pushToPop();
    }

    public int poll() {
        if (stackPop.empty() && stackPush.empty()) {
            throw new RuntimeException("queue is empty");
        }
        pushToPop();
        return stackPop.pop();
    }

    public int peek() {
        if (stackPop.empty() && stackPush.empty()) {
            throw new RuntimeException("queue is empty");
        }
        pushToPop();
        return stackPop.peek();
    }

    public static void main(String[] args) {

        TwoStackImplementQueue queue = new TwoStackImplementQueue();
        queue.add(1);
        queue.add(2);
        queue.add(3);
        System.out.println(queue.peek());
        System.out.println(queue.poll());
        System.out.println(queue.peek());
        System.out.println(queue.poll());
        System.out.println(queue.peek());
        System.out.println(queue.poll());
    }
}

```