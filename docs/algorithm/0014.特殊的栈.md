## 特殊的栈

### 算法介绍

每次入栈时，记录当前栈的最小值。出栈时，如果出栈的元素是当前最小值，则更新当前最小值。

### 算法思路

1. 使用两个栈：一个主栈用于存储所有元素，另一个辅助栈用于存储当前的最小值。
2. 入栈操作时，如果新元素小于或等于辅助栈的栈顶元素，则将其压入辅助栈。
3. 出栈操作时，如果出栈的元素等于辅助栈的栈顶元素，则同时从辅助栈中弹出。
4. 获取最小值时，直接返回辅助栈的栈顶元素。

### 算法实现
```java
package lesson.stackandqueue;

import java.util.Stack;

/**
 * 直接获取最小值的特殊的栈
 *
 * @author mark
 *
 */


public class GetMinStack {
    private Stack<Integer> stackData;
    private Stack<Integer> stackMin;

    public GetMinStack() {
        this.stackData = new Stack<>();
        this.stackMin = new Stack<>();
    }

    public void push(int num) {
        if (this.stackMin.isEmpty()) {
            stackMin.push(num);
        } else {
            stackMin.push(Math.min(this.getMin(), num));
        }
        stackData.push(num);
    }

    public int pop() {
        if (this.stackData.isEmpty()) {
            throw new RuntimeException("stack is empty");
        }
        this.stackMin.pop();
        return this.stackData.pop();
    }

    public int getMin() {
        if (this.stackMin.isEmpty()) {
            throw new RuntimeException("stack is empty");
        }
        return this.stackMin.peek();
    }

    public static void main(String[] args) {
        GetMinStack stack = new GetMinStack();
        stack.push(3);
        System.out.println(stack.getMin());
        stack.push(5);
        System.out.println(stack.getMin());
        stack.push(1);
        System.out.println(stack.getMin());
        System.out.println(stack.pop());
        System.out.println(stack.getMin());
    }
}

```