## 数组实现循环队列

### 算法介绍

循环队列是一种特殊的队列结构，它的特点是当队列的尾部到达数组的末尾时，可以回绕到数组的开头，从而实现循环使用数组空间。
循环队列可以有效地利用数组空间，避免了传统队列在出队操作后留下的空闲空间。

### 实现思路

1. **数组存储**：使用一个数组来存储队列元素。
2. **头尾指针**：使用两个指针 `head` 和 `tail` 分别指向队列的头部和尾部。
3. **循环索引**：当 `tail` 指向数组的末尾时，下一个元素将回绕到数组的开头。同样，`head` 也会循环移动。
4. **队列操作**：
    - **入队**：将元素添加到 `tail` 指向的位置，然后更新 `tail` 指针。
    - **出队**：从 `head` 指向的位置移除元素，然后更新 `head` 指针。
    - **查看队首元素**：直接返回 `head` 指向的元素。
5. **队列状态**：通过维护一个 `size` 变量来跟踪队列的当前大小，以判断队列是否为空或已满。
6. **边界条件**：确保在入队和出队操作中正确处理队列满和队列空的情况。

### 代码示例

```java
package lesson.stackandqueue;

/**
 * 数组实现循环队列
 *
 * @author mark
 *
 */


public class CircularQueue<T> {
    private Object[] queue; // 存储队列元素的数组
    private int head;   // 队首索引
    private int tail;    // 队尾索引
    private int size;    // 队列当前大小
    private final int capacity; // 队列容量

    public CircularQueue(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("容量必须大于0");
        }
        this.capacity = capacity;
        // 使用Object数组，避免泛型数组创建的类型擦除问题
        this.queue = new Object[capacity];
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }


    public Boolean isFull() {
        return size == capacity;
    }

    public Boolean isEmpty() {
        return size == 0;
    }

    private int nextIndex(int i) {
        return i < capacity - 1 ? i + 1 : 0;
    }

    /**
     * 将指定元素添加到队列中
     *
     * @param value 添加的元素
     */
    public void push(T value) {
        if (isFull()) {
            throw new RuntimeException("队列已满");
        }
        queue[tail] = value;
        tail = nextIndex(tail);
        size++;
    }

    @SuppressWarnings("unchecked")
    public T poll() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        T value = (T) queue[head];
        queue[head] = null;
        head = nextIndex(head);
        size--;
        return value;
    }

    @SuppressWarnings("unchecked")
    public T peek() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空");
        }
        return (T) queue[head];
    }

    public static void main(String[] args) {
        CircularQueue<Integer> queue = new CircularQueue<>(5);
        System.out.println(queue.head);
        queue.push(1);
        queue.push(3);
        queue.push(5);
        queue.push(7);
        queue.push(9);
        System.out.println(queue.tail);
        System.out.println(queue.size);

        System.out.println(queue.poll());
        System.out.println(queue.head);
        System.out.println(queue.poll());
        System.out.println(queue.head);

        queue.push(11);
        System.out.println(queue.head + " " + queue.tail);
    }
}


```
