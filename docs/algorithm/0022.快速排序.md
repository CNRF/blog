---
title: '0022.快速排序'
tags: [ '' ]
categories: [ '' ]
---

## 题目

[快速排序](https://leetcode.cn/problems/sort-an-array/description/)
给你一个整数数组 nums，请你将该数组升序排列。

### 例子

输入：nums = [5,2,3,1]
输出：[1,2,3,5]

## 思路

1. 选择一个基准元素（通常是数组的最后一个元素）。
2. 使用两个指针，`less` 指向小于基准元素的区域的末尾，`more` 指向大于基准元素的区域的开始。
3. 遍历数组，将元素与基准元素进行比较，并根据比较结果将元素放入相应的区域。
4. 最后，将基准元素放到正确的位置上，并递归地对左右两个子数组进行排序。

## 实现

### netherlandsFlag方法解析

1. `netherlandsFlag` 方法的作用是将数组划分为三个部分：小于基准值、等于基准值和大于基准值。
2. `less` 和 `more` 分别表示小于区域的右边界和大于区域的左边界。
3. 使用一个指针 `index` 来遍历数组，根据当前元素与基准值的比较结果，将元素放入相应的区域。
4. 最后，将基准值与大于区域的第一个元素交换，确保基准值在中间位置。
5. 返回基准值所在区域的左右边界。

### 代码

```java
package lesson.sort;

/**
 * 快速排序
 *
 * @author mark
 *
 */


public class QuickSort {
    public static void quickSort(int[] arr) {
        if (null == arr || arr.length < 2) {
            return;
        }
        process(arr, 0, arr.length - 1);
    }

    public static void process(int[] arr, int left, int right) {
        if (left >= right) {
            return;
        }
        // 随机选择一个数作为基准值，保证算法的时间复杂度是O(N*logN)
        int random = (int) (Math.random() * (right - left + 1));
        swap(arr, left + random, right);
        int[] ints = netherlandsFlag(arr, left, right);
        process(arr, left, ints[0] - 1);
        process(arr, ints[1] + 1, right);
    }

    /**
     * 返回基准值后的数组左边界和有边界
     *
     * @param arr   数组
     * @param left  排序做边界
     * @param right 排序右边界
     * @return int[]  返回基准值后的数组左边界和有边界
     */
    public static int[] netherlandsFlag(int[] arr, int left, int right) {
        if (left > right) {
            return new int[]{-1, -1};
        }
        if (left == right) {
            return new int[]{left, right};
        }
        int less = left - 1; // < 区 右边界
        int more = right; // > 区 左边界
        int index = left;
        // 当前数在 > 区的左边遍历，以arr[right]作为基准值,
        // 保证<arr[right]的数在左边，>arr[right]的数在右边
        while (index < more) { // index是当前数，遍历到more位置就停止
            if (arr[index] == arr[right]) {
                index++;
            } else if (arr[index] < arr[right]) {
                swap(arr, index++, ++less);
            } else {
                swap(arr, index, --more);
            }
        }
        // 最后把基准值和 > 区的第一个数交换，保证基准值在中间
        swap(arr, more, right);
        return new int[]{less + 1, right};
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    public static void main(String[] args) {
        int[] arr = {6, 3, 9, 1};
        quickSort(arr);
        for (int i : arr) {
            System.out.println(i);
        }
    }
}

```